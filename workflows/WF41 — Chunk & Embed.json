{
  "name": "WF41 — Chunk & Embed",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "3266fe36-6af7-4bc3-a978-731b6966af99",
      "name": "IN — Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1536,
        1024
      ],
      "notes": "PURPOSE: Worker entry from WF90 Execute Workflow. INPUT: single item with req{ctx,job}. OUTPUT: raw worker request. WHY: canonical worker trigger."
    },
    {
      "parameters": {},
      "id": "9fd5004b-56fa-4295-8ba5-b0443ddc54ec",
      "name": "TEST — Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1536,
        1456
      ],
      "notes": "PURPOSE: Run DB-backed T1/T2/T3 tests inside WF41. INPUT: manual click. OUTPUT: test requests merged into main pipeline. WHY: required regression checks."
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      req: {\n        ctx: {\n          tenant_id: '00000000-0000-0000-0000-000000000041',\n          correlation_id: '41000000-0000-0000-0000-000000000001',\n          trace_id: null,\n          chat_id: null,\n          message_id: null,\n          workflow: 'WF90',\n          job_id: 410001\n        },\n        job: {\n          id: 410001,\n          job_type: 'chunk_document',\n          payload: {\n            document_id: 410001,\n            strategy: 'default'\n          }\n        }\n      },\n      _test: { id: 'T1', expect: 'happy' }\n    }\n  },\n  {\n    json: {\n      req: {\n        ctx: {\n          tenant_id: '00000000-0000-0000-0000-000000000041',\n          correlation_id: '41000000-0000-0000-0000-000000000002',\n          trace_id: null,\n          chat_id: null,\n          message_id: null,\n          workflow: 'WF90',\n          job_id: 410002\n        },\n        job: {\n          id: 410002,\n          job_type: 'chunk_document',\n          payload: {\n            document_id: 410002,\n            strategy: 'default'\n          }\n        }\n      },\n      _test: { id: 'T2', expect: 'empty_text' }\n    }\n  },\n  {\n    json: {\n      req: {\n        ctx: {\n          tenant_id: '00000000-0000-0000-0000-000000000041',\n          correlation_id: '41000000-0000-0000-0000-000000000003',\n          trace_id: null,\n          chat_id: null,\n          message_id: null,\n          workflow: 'WF90',\n          job_id: 410003\n        },\n        job: {\n          id: 410003,\n          job_type: 'chunk_document',\n          payload: {\n            document_id: 999999999\n          }\n        }\n      },\n      _test: { id: 'T3', expect: 'wf99_error' }\n    }\n  }\n];"
      },
      "id": "501d7ad8-2a8c-4e1d-bb7c-12e37467ff9b",
      "name": "TEST — Build Requests",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1296,
        1456
      ],
      "notes": "PURPOSE: Emit three required test requests (T1/T2/T3) that reuse production pipeline. INPUT: manual trigger. OUTPUT: items with req.ctx/req.job. WHY: deterministic test harness."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "passThrough"
      },
      "id": "8e6d9f59-cc5a-4e3d-b7be-a9e6f6011ec9",
      "name": "Merge — IN (WF90 + TEST)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1056,
        1024
      ],
      "notes": "PURPOSE: Unify WF90 runtime input and manual test input. INPUT1: trigger. INPUT2: test requests. OUTPUT: one canonical stream. WHY: tests must reuse core logic, no mock branch."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a4f9f3a5-c342-4aa7-8618-24f33f4a02b2",
              "name": "req.ctx",
              "value": "={{ $json.req?.ctx || $json.ctx }}",
              "type": "object"
            },
            {
              "id": "a4f9f3a5-c342-4aa7-8618-24f33f4a02b3",
              "name": "req.job",
              "value": "={{ $json.req?.job || $json.job }}",
              "type": "object"
            },
            {
              "id": "8c7f7f9a-12d9-4c21-ac3a-8253126ea7f6",
              "name": "ctx",
              "value": "={{ $json.req?.ctx || $json.ctx }}",
              "type": "object"
            },
            {
              "id": "3a36975b-87dd-4708-af79-7377e2b66d75",
              "name": "job",
              "value": "={{ $json.req?.job || $json.job }}",
              "type": "object"
            },
            {
              "id": "d1578f59-4b0f-4f0e-8fc1-ae3c8e8d4f5d",
              "name": "ctx.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "c61f9fe6-2af4-4986-b6aa-2e616a8a9c66",
              "name": "ctx.contracts.errorpipe",
              "value": 1,
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "0087a0e9-6e46-4d72-b933-c15efa7fef72",
      "name": "Set — Normalize Input",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -816,
        1024
      ],
      "notes": "PURPOSE: Normalize WF90 request contract for worker execution. INPUT: either {req:{ctx,job}} or {ctx,job} (both forms accepted). OUTPUT: req.ctx + req.job + ctx + job canonical fields. WHY: all downstream nodes expect stable $json.req.* structure; dual input format for caller flexibility."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "0f4048f3-4bbf-422c-94b8-38e4958db895",
              "leftValue": "={{ $json.req?.ctx }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "ed74cc42-a5bc-4f5f-a7f1-a4b7dcfd2d1e",
              "leftValue": "={{ $json.req?.job }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "cbf41d09-0aa8-4fb9-b76e-b8c3f4fc2ab0",
              "leftValue": "={{ $json.req?.job?.payload?.document_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "06f7fa10-76bd-47b2-8703-910ba50af431",
      "name": "GUARD — Preflight Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -560,
        1184
      ],
      "notes": "PURPOSE: Validate req.ctx, req.job, and payload.document_id before routing. INPUT: normalized request. OUTPUT TRUE: valid; FALSE: managed validation error. WHY: Step 0 preflight requirement."
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 3
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.req?.job?.job_type }}",
                    "rightValue": "chunk_document",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "f7f93bda-53cb-4454-bb0e-f89e1a2d57ad"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "chunk_document"
            },
            {
              "conditions": {
                "options": {
                  "version": 3
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.req?.job?.job_type }}",
                    "rightValue": "embed_chunks",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e97ae48d-ad4a-4ef0-a981-1826e7f80e3f"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "embed_chunks"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "8e376935-0007-4050-ba3d-9880d8358b36",
      "name": "SWITCH — Route job_type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -336,
        976
      ],
      "notes": "PURPOSE: Route execution to chunk_document or embed_chunks path. INPUT: validated req/job. OUTPUTS: chunk_document, embed_chunks, fallback. WHY: strict worker dispatch by ops.job_type."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "content",
          "mode": "list",
          "cachedResultName": "content"
        },
        "table": {
          "__rl": true,
          "value": "documents",
          "mode": "list",
          "cachedResultName": "documents"
        },
        "where": {
          "values": [
            {
              "column": "id",
              "value": "={{ $json.req.job.payload.document_id }}"
            },
            {
              "column": "tenant_id",
              "value": "={{ $json.req.ctx.tenant_id }}"
            }
          ]
        },
        "options": {}
      },
      "id": "efae27c4-8371-44bf-b019-4d89991e8cf4",
      "name": "DB — Select Document",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -48,
        880
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Load content.documents by tenant_id + document_id for chunking and embedding. INPUT: req.ctx + req.job.payload.document_id. OUTPUT: document row. WHY: authoritative source text/status/hash."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "ddd29e8b-df2e-4e0f-b310-67c5811c96af",
      "name": "Merge — Restore CTX after DB Document",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        144,
        720
      ],
      "notes": "PURPOSE: Carry/restore req, ctx, and job after Postgres select overwrite. INPUT1: DB row. INPUT2: pre-DB item. OUTPUT: document + req/ctx/job. WHY: mandatory carry pattern after I/O."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "25727870-40e3-49c2-ae54-5c916d3a4221",
              "leftValue": "={{ ($json.document_text || \"\").trim() }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "f396cc5c-520d-4aa4-9cf0-36e97f290eb0",
      "name": "GUARD — Document Has Text",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        416,
        608
      ],
      "notes": "PURPOSE: Skip chunking when document text is empty/whitespace. INPUT: loaded document. OUTPUT TRUE: chunkable text; FALSE: success skipped empty_text. WHY: required Step A.2 guard."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "5c6f9f34-57d1-459d-8d0f-bc8b475a3f0e",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "7f4bb778-cc03-4900-b302-a16dc64fd070",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "f1baf875-cfc8-4f15-947d-f70435f47c38",
              "name": "data.document_id",
              "value": "={{ $json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "740f93f7-2f85-4fcb-a2c1-3f5a1030485f",
              "name": "data.skipped",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "37020da8-8b0e-4e3a-8bf7-0671de3f1508",
              "name": "data.reason",
              "value": "empty_text",
              "type": "string"
            },
            {
              "id": "cc616176-b6fe-47bb-bb85-9df66469d76b",
              "name": "error",
              "value": null,
              "type": "object"
            },
            {
              "id": "97bf7a1d-f60b-4bb6-b168-f31f326f0990",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "7885eae8-24b2-4380-b2d6-452d46f8356e",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "5d8f1bad-1597-4465-8eec-a4986f4b4ba8",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "9f8bbf84-8e49-42ac-b77f-8c7b9305b670",
              "name": "meta.correlation.trace_id",
              "value": "={{ $json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "f84fbf11-af5e-4491-b6db-73caec53f90f",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "b4ba2ffc-ef66-48fc-ad65-2f81f082a549",
              "name": "meta.correlation.chat_id",
              "value": "={{ $json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "3dceeb67-5cf8-44c0-9838-95f773be1010",
              "name": "meta.correlation.message_id",
              "value": "={{ $json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "a9f71be0-36fa-42bc-a39e-3f1ccfe83d0d",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "9bb8f1b1-a36b-4656-ab65-4ecd89f7b92a",
              "name": "meta.correlation.node",
              "value": "GUARD — Document Has Text",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "2e4739c3-39f2-4505-bee9-5886a9e37c84",
      "name": "OUT — Success Empty Text",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1344,
        976
      ],
      "notes": "PURPOSE: Return SuccessEnvelope for empty text without enqueueing embed job. INPUT: text guard false. OUTPUT: ok=true skipped=empty_text. WHY: required non-error skip behavior."
    },
    {
      "parameters": {
        "type": "SHA256",
        "value": "={{ $json.document_text }}",
        "dataPropertyName": "hash"
      },
      "id": "4e84d8b3-88b8-464b-bed8-a2d8b509480b",
      "name": "Crypto — Hash Document Text",
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        624,
        544
      ],
      "notes": "PURPOSE: Compute SHA256 for current document text. INPUT: document.text. OUTPUT: hash hex. WHY: idempotency and document.text_sha256 maintenance."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        },
        "limit": 1,
        "where": {
          "values": [
            {
              "column": "document_id",
              "value": "={{ $json.req.job.payload.document_id }}"
            }
          ]
        },
        "options": {}
      },
      "id": "6512a55a-a8c7-4b18-b9a2-393cae028a4a",
      "name": "DB — Probe Existing Chunks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        864,
        544
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Probe whether chunks already exist for document_id. INPUT: document_id. OUTPUT: first chunk row or none. WHY: idempotency decision before rechunking."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8b16804a-fad7-4f27-bdcf-c94eec4b0b6f",
              "name": "doc_hash_hex",
              "value": "={{ $('Crypto — Hash Document Text').item.json.hash }}",
              "type": "string"
            },
            {
              "id": "6e4ec801-2989-4675-8d1f-f7577b37919b",
              "name": "doc_hash_bytea",
              "value": "={{ '\\\\x' + $('Crypto — Hash Document Text').item.json.hash }}",
              "type": "string"
            },
            {
              "id": "2e6512f7-c912-486e-bdc5-7c5cc6118a9a",
              "name": "has_chunks",
              "value": "={{ $items('DB — Probe Existing Chunks').filter(i => i.json && i.json.id !== undefined && i.json.id !== null).length > 0 }}",
              "type": "boolean"
            },
            {
              "id": "f024e4c9-5639-4fdb-aaf3-4de4ea335774",
              "name": "old_hash",
              "value": "={{ ((($('Set — Read Document Fields').item.json.stored_text_sha256 || '') + '')).replace('\\\\x','') }}",
              "type": "string"
            },
            {
              "id": "addfeacb-a482-4b35-b393-2b7d744de2cf",
              "name": "needs_rechunk",
              "value": "={{ $json.req.job.payload.force === true || ($items('DB — Probe Existing Chunks').filter(i => i.json && i.json.id !== undefined && i.json.id !== null).length === 0) || ((((($('Set — Read Document Fields').item.json.stored_text_sha256 || '') + '')).replace('\\\\x','')) !== $('Crypto — Hash Document Text').item.json.hash) }}",
              "type": "boolean"
            },
            {
              "id": "a6f34f54-b410-497e-a9f6-a68f8f8913f4",
              "name": "text",
              "value": "={{ $('Set — Read Document Fields').item.json.document_text }}",
              "type": "string"
            },
            {
              "id": "04f0ff43-4ba9-4531-827e-7e8e0dbf71e8",
              "name": "req",
              "value": "={{ $('Set — Read Document Fields').item.json.req }}",
              "type": "object"
            },
            {
              "id": "3a7f7be5-f028-4496-a886-3c3ea42cd7d4",
              "name": "ctx",
              "value": "={{ $('Set — Read Document Fields').item.json.ctx }}",
              "type": "object"
            },
            {
              "id": "852cb9ce-8776-4706-8efe-273fa63d745e",
              "name": "job",
              "value": "={{ $('Set — Read Document Fields').item.json.job }}",
              "type": "object"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "69748c80-cfa9-4ed3-b5e8-b6a219e84ced",
      "name": "Set — Decide Rechunk",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1104,
        480
      ],
      "notes": "PURPOSE: Build hash/idempotency state and carry context. INPUT: hash + chunk probe + document row. OUTPUT: needs_rechunk, hashes, req/ctx/job/text. WHY: controlled branch for stale/fresh chunks."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "f843f0f5-966f-4f82-9892-9c0d282db986",
              "leftValue": "={{ $json.needs_rechunk }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "a0a97ac0-6fa3-4378-a639-b005f430dcb9",
      "name": "IF — Needs Rechunk",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1344,
        512
      ],
      "notes": "PURPOSE: Skip expensive rechunk when current hash already chunked. INPUT: idempotency state. OUTPUT TRUE: rechunk; FALSE: already_chunked success. WHY: idempotent worker behavior."
    },
    {
      "parameters": {
        "operation": "delete",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        }
      },
      "id": "8306a9b3-1e8b-4cad-8559-9c31ec808568",
      "name": "DB — Delete Old Chunks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1584,
        544
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Remove stale chunks for document before rewrite. INPUT: document_id. OUTPUT: delete result. WHY: stale data cleanup; embeddings cascade via FK ON DELETE CASCADE."
    },
    {
      "parameters": {
        "jsCode": "const txt = ($json.text || '').toString();\nconst strategy = ($json.req?.job?.payload?.strategy || 'default').toLowerCase();\nlet size = 1200;\nlet overlap = 120;\nif (strategy === 'small') { size = 700; overlap = 80; }\nif (strategy === 'large') { size = 1800; overlap = 180; }\nconst out = [];\nif (!txt.trim()) return [];\nlet i = 0;\nlet no = 0;\nwhile (i < txt.length) {\n  const end = Math.min(txt.length, i + size);\n  const chunkText = txt.slice(i, end);\n  out.push({ json: {\n    req: $json.req,\n    ctx: $json.ctx,\n    job: $json.job,\n    document_id: $json.req.job.payload.document_id,\n    embedding_model_id: $json.req.job.payload.embedding_model_id || null,\n    doc_hash_hex: $json.doc_hash_hex,\n    doc_hash_bytea: $json.doc_hash_bytea,\n    chunk_no: no,\n    char_start: i,\n    char_end: end,\n    chunk_text: chunkText\n  }});\n  if (end >= txt.length) break;\n  i = Math.max(end - overlap, i + 1);\n  no += 1;\n}\nreturn out;"
      },
      "id": "43dcbad3-7d52-473f-8f0a-a197f8925f9d",
      "name": "CODE — Build Chunks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        480
      ],
      "notes": "PURPOSE: Split text into chunk items with strategy-aware size/overlap. INPUT: text + req + hash state. OUTPUT: one item per chunk with positions. WHY: no splitter node in repo examples; controlled deterministic chunking."
    },
    {
      "parameters": {
        "type": "SHA256",
        "value": "={{ $json.chunk_text }}",
        "dataPropertyName": "hash"
      },
      "id": "1d1ec880-bb2a-4bd1-b7c7-04df78f5402e",
      "name": "Crypto — Hash Chunk",
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        2768,
        -224
      ],
      "notes": "PURPOSE: Compute SHA256 for each chunk text. INPUT: chunk_text. OUTPUT: hash hex. WHY: chunk-level idempotency metadata."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8f35993f-8d83-40f0-be8b-c4ed98d3f3af",
              "name": "meta.chunk_sha256",
              "value": "={{ $json.hash }}",
              "type": "string"
            },
            {
              "id": "1bc6dc79-2fa8-4bc6-8841-6ea6b6659653",
              "name": "meta.document_sha256",
              "value": "={{ $json.doc_hash_hex }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "f1e37a65-a739-48d4-aaca-1904f527cb62",
      "name": "Set — Prepare Chunk Row",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3280,
        -224
      ],
      "notes": "PURPOSE: Build kg.chunks row payload with meta hashes. INPUT: hashed chunk item. OUTPUT: chunk fields + meta.*. WHY: align with SQL schema and upsert key."
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "document_id": "={{ $json.document_id }}",
            "chunk_no": "={{ $json.chunk_no }}",
            "char_start": "={{ $json.char_start }}",
            "char_end": "={{ $json.char_end }}",
            "text": "={{ $json.chunk_text }}",
            "meta": "={{ $json.meta }}"
          },
          "matchingColumns": [
            "document_id",
            "chunk_no"
          ],
          "schema": [
            {
              "id": "document_id",
              "displayName": "document_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "chunk_no",
              "displayName": "chunk_no",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "char_start",
              "displayName": "char_start",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": false
            },
            {
              "id": "char_end",
              "displayName": "char_end",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": false
            },
            {
              "id": "text",
              "displayName": "text",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "meta",
              "displayName": "meta",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": false
            }
          ]
        },
        "options": {}
      },
      "id": "4ad46e70-bb3d-4a6c-8e84-06f2fa3f6318",
      "name": "DB — Upsert Chunk",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3712,
        -96
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Upsert chunk rows into kg.chunks on unique(document_id,chunk_no). INPUT: chunk row payload. OUTPUT: upsert result. WHY: idempotent chunk persistence without SQL query node."
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "value": "ops",
          "mode": "list",
          "cachedResultName": "ops"
        },
        "table": {
          "__rl": true,
          "value": "jobs",
          "mode": "list",
          "cachedResultName": "jobs"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $json.enqueue.tenant_id }}",
            "job_type": "={{ $json.enqueue.job_type }}",
            "payload": "={{ $json.enqueue.payload }}",
            "correlation_id": "={{ $json.enqueue.correlation_id }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "tenant_id",
              "displayName": "tenant_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "job_type",
              "displayName": "job_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "options",
              "canBeUsedToMatch": true,
              "options": [
                {
                  "name": "embed_chunks",
                  "value": "embed_chunks"
                }
              ]
            },
            {
              "id": "payload",
              "displayName": "payload",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "correlation_id",
              "displayName": "correlation_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ]
        },
        "options": {}
      },
      "id": "0ce02eb7-f06e-4f48-92ff-8818a21fce7a",
      "name": "DB — Enqueue embed_chunks Job",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1776,
        272
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Enqueue follow-up embed_chunks job in ops.jobs. INPUT: tenant_id, document_id, selected embedding_model_id, correlation_id. OUTPUT: inserted job row. WHY: decouple chunking and embedding workers."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "bd4bfce4-b360-4fa7-a38d-74dbf01cc0f5",
              "name": "embedding_model_id",
              "value": "={{ $json.id || $(\"Set — Normalize Input\").item.json.req.job.payload.embedding_model_id || null }}",
              "type": "number"
            },
            {
              "id": "wf41-setsel-req-model",
              "name": "req.job.payload.embedding_model_id",
              "value": "={{ $json.id || $(\"Set — Normalize Input\").item.json.req.job.payload.embedding_model_id || null }}",
              "type": "number"
            },
            {
              "id": "wf41-setsel-model-key",
              "name": "model_key",
              "value": "={{ $json.model_key || null }}",
              "type": "string"
            },
            {
              "id": "wf41-setsel-model-dim",
              "name": "output_dim",
              "value": "={{ Number($json.output_dim || 0) }}",
              "type": "number"
            },
            {
              "id": "wf41-setsel-model-active",
              "name": "is_active",
              "value": "={{ $json.is_active === true }}",
              "type": "boolean"
            },
            {
              "id": "wf41-setsel-ctx",
              "name": "ctx",
              "value": "={{ $(\"Set — Normalize Input\").item.json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-setsel-job",
              "name": "job",
              "value": "={{ $(\"Set — Normalize Input\").item.json.job }}",
              "type": "object"
            },
            {
              "id": "wf41-setsel-req",
              "name": "req",
              "value": "={{ $(\"Set — Normalize Input\").item.json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "0dfaba3c-9d40-41c7-930a-3f7afebf0d1a",
      "name": "Set — Select Embedding Model",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3840,
        592
      ],
      "notes": "PURPOSE: Resolve embedding_model_id from payload override or default model lookup and write back into req.job.payload.embedding_model_id. INPUT: payload and/or default model row. OUTPUT: embedding_model_id + normalized req/ctx/job. WHY: both chunk_document enqueue and embed_chunks path require deterministic resolved model id."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "embedding_models",
          "mode": "list",
          "cachedResultName": "embedding_models"
        },
        "limit": 1,
        "where": {
          "values": [
            {
              "column": "is_active",
              "value": "={{ true }}"
            }
          ]
        },
        "sort": {
          "values": [
            {
              "column": "id"
            }
          ]
        },
        "options": {}
      },
      "id": "0d6b5e2d-7075-4683-a3ca-9d340b9f4696",
      "name": "DB — Select Default Embedding Model",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2784,
        416
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Fetch deterministic default embedding model (first active by id). INPUT: req context. OUTPUT: model row or empty item (always output). WHY: payload embedding_model_id may be absent for both chunk_document enqueue and embed_chunks execution."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "af6ccdf8-f162-4e0c-a8c2-4f2c33ac9d34",
              "leftValue": "={{ $json.req?.job?.payload?.embedding_model_id || $(\"Set — Normalize Input\").item.json.req?.job?.payload?.embedding_model_id || \"\" }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "d3b5c6e7-cbac-4303-a3bb-86396ea2cc6f",
      "name": "IF — Payload Has Embedding Model",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1984,
        -176
      ],
      "notes": "PURPOSE: Branch model resolution based on payload.embedding_model_id. INPUT: chunk state. OUTPUT TRUE: use payload model; FALSE: load default model. WHY: required enqueue model selection rule."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1d1ebf7f-7f0d-4705-987b-4d14c833f952",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "e3ae3f0d-fcfe-472a-93db-f1ef03d4f712",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "ba1feef6-b0de-4021-94a6-41f86ffbd90d",
              "name": "data.document_id",
              "value": "={{ $json.req?.job?.payload?.document_id || $(\"Set — Decide Rechunk\").item.json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "801ae7e1-a9bc-4327-a5d9-b7d8c81a7e7d",
              "name": "data.chunk_count",
              "value": "={{ $items('DB — Upsert Chunk').length }}",
              "type": "number"
            },
            {
              "id": "6f7a353d-a414-43bc-abd8-9148e8d5f27c",
              "name": "data.embed_enqueued",
              "value": "={{ $json.embed_enqueued === true }}",
              "type": "boolean"
            },
            {
              "id": "f06c0c87-e36f-40de-a283-c823072078cf",
              "name": "data.embedding_model_id",
              "value": "={{ $json.req?.job?.payload?.embedding_model_id || $(\"Set — Select Embedding Model\").item.json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "fe4634d5-88fc-4de9-af49-0e7eb11f6978",
              "name": "error",
              "value": null,
              "type": "object"
            },
            {
              "id": "013ed014-e958-4020-90f2-1897de4af8ec",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "f61954f6-3b5a-4949-830d-a38d7d4d0f3a",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "0f7807fc-e3b8-4a73-9837-5e7c089670ff",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $json.req?.ctx?.correlation_id || $(\"Set — Decide Rechunk\").item.json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "0818f370-fafa-4f3d-8e88-62356e33d7f4",
              "name": "meta.correlation.trace_id",
              "value": "={{ $json.req?.ctx?.trace_id || $(\"Set — Decide Rechunk\").item.json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "0051f5af-35f4-4b81-a53c-c423dd10f6ee",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $json.req?.ctx?.tenant_id || $(\"Set — Decide Rechunk\").item.json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "bb07f835-60a1-4ef5-a954-f4a211d4f20e",
              "name": "meta.correlation.chat_id",
              "value": "={{ $json.req?.ctx?.chat_id || $(\"Set — Decide Rechunk\").item.json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "e2520a61-d97f-4f74-b2f5-8e5e13b53f08",
              "name": "meta.correlation.message_id",
              "value": "={{ $json.req?.ctx?.message_id || $(\"Set — Decide Rechunk\").item.json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "4f0e90b5-d0fd-4f11-9128-5239e66e9e6b",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "4f0719b8-6585-4051-a6c4-e88ee2c980d2",
              "name": "meta.correlation.node",
              "value": "DB — Enqueue embed_chunks Job",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "811e0d29-c0ba-48bc-8504-4ea7b4eeb666",
      "name": "OUT — Success Chunk",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2192,
        16
      ],
      "notes": "PURPOSE: Build SuccessEnvelope for chunk_document happy path. INPUT: enqueue result + resolved model + chunk stats. OUTPUT: contract envelope. WHY: required WF41 success contract."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "3dfe123b-2f49-489c-a30d-2f9189df533f",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "69c97c4c-fd82-4902-b74f-e19f36f443a6",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "d8e94bec-1178-4d28-8c63-4a4ae67cc7d4",
              "name": "data.document_id",
              "value": "={{ $json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "17155f31-77ec-4d46-ba44-8db6cc3d95f4",
              "name": "data.skipped",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "b3d50548-e00f-4a57-9ce7-0e6f314f44aa",
              "name": "data.reason",
              "value": "already_chunked",
              "type": "string"
            },
            {
              "id": "f19b5e8f-bbca-44d0-8cf5-bf09c95ba91a",
              "name": "error",
              "value": null,
              "type": "object"
            },
            {
              "id": "fd5fa842-444e-477d-a9f7-2f4924d7ed48",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "4d00a0c4-df96-4df8-93ff-c2f90c980d15",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "a1b47db6-a5dd-4a1f-8f78-f5a1f31fcc23",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "5ce4548c-2eb8-4ec3-8641-02441f114ef9",
              "name": "meta.correlation.trace_id",
              "value": "={{ $json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "a8908c97-587e-4837-9dc4-5953f9f6c76e",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "a18480c6-b8b5-4dcd-ba07-7954b10af03c",
              "name": "meta.correlation.chat_id",
              "value": "={{ $json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "dc2b7c0b-a9eb-4515-8625-11e7c18fba26",
              "name": "meta.correlation.message_id",
              "value": "={{ $json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "3b8868f5-d051-4239-be29-c2494ad9fddb",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "7418a010-27d0-4510-80b7-8d8544d3d2ec",
              "name": "meta.correlation.node",
              "value": "IF — Needs Rechunk",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "79110074-d0bb-42f1-abcf-0982a2cd1932",
      "name": "OUT — Success Already Chunked",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2000,
        912
      ],
      "notes": "PURPOSE: Return SuccessEnvelope when chunks are up-to-date and no rechunk needed. INPUT: idempotency false branch. OUTPUT: skipped already_chunked envelope. WHY: idempotent short-circuit."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-input-guard-node",
              "name": "_err.node",
              "value": "GUARD — Preflight Input",
              "type": "string"
            },
            {
              "id": "wf41-input-guard-op",
              "name": "_err.operation",
              "value": "validate_input",
              "type": "string"
            },
            {
              "id": "wf41-input-guard-table",
              "name": "_err.table",
              "value": "workflow.input",
              "type": "string"
            },
            {
              "id": "wf41-input-guard-kind",
              "name": "_err.kind",
              "value": "validation",
              "type": "string"
            },
            {
              "id": "wf41-input-guard-msg",
              "name": "_err.message",
              "value": "Missing req.ctx, req.job, or req.job.payload.document_id",
              "type": "string"
            },
            {
              "id": "wf41-input-guard-status",
              "name": "_err.status_code",
              "value": 400,
              "type": "number"
            },
            {
              "id": "wf41-input-guard-retry",
              "name": "_err.retryable",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "wf41-input-guard-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-input-guard-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "0093a50c-5d94-41bc-b6e5-57b4c84224c4",
      "name": "ERR — Source Input Guard",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5888,
        2560
      ],
      "notes": "PURPOSE: Mark validation source metadata for ErrorPipe. INPUT: guard false branch. OUTPUT: _err.* + ctx/req for WF99. WHY: managed validation error handling."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-kind",
              "name": "error_context.kind",
              "value": "={{ $json._err?.kind || \"unknown\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-msg",
              "name": "error_context.error_message",
              "value": "={{ $json._err?.message || $json.error?.message || $json.message || \"WF41 failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-status",
              "name": "error_context.status_code",
              "value": "={{ Number($json._err?.status_code || $json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-retry",
              "name": "error_context.retryable",
              "value": "={{ $json._err?.retryable !== undefined ? $json._err.retryable : false }}",
              "type": "boolean"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-node",
              "name": "error_context.node",
              "value": "={{ $json._err?.node || null }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-op",
              "name": "error_context.operation",
              "value": "={{ $json._err?.operation || null }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-table",
              "name": "error_context.table",
              "value": "={{ $json._err?.table || null }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-ctx",
              "name": "error_context.ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Input)-ctx-contract",
              "name": "ctx.contracts.errorpipe",
              "value": 1,
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "8d317fd0-2541-4e77-b59c-2859c8e6f770",
      "name": "ERR — Prepare ErrorPipe v1 (Input)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        6160,
        2560
      ],
      "notes": "PURPOSE: Build ErrorPipe v1 payload for validation failures. INPUT: err source item. OUTPUT: error_context.* for WF99. WHY: WF41 must delegate envelope creation to WF99."
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gcM1ZRVCKVtzJfHOH7OTw",
          "mode": "list",
          "cachedResultUrl": "/workflow/gcM1ZRVCKVtzJfHOH7OTw",
          "cachedResultName": "WF99 — Global ERR Handler"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "fce66118-0218-42d0-86b1-078e7faac513",
      "name": "Execute WF99 (Input)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        6400,
        2560
      ],
      "notes": "PURPOSE: Delegate managed validation errors to WF99 and return its ErrorEnvelope. INPUT: error_context. OUTPUT: WF99 envelope. WHY: centralized error pipeline."
    },
    {
      "parameters": {
        "mode": "chooseBranch"
      },
      "id": "78fae714-b54f-4bcb-a230-0e74db072244",
      "name": "Merge — Final (Success + WF99)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        6624,
        1216
      ],
      "notes": "PURPOSE: Merge terminal success and WF99 error envelopes into workflow output stream. INPUTS: success envelopes (input 0) and WF99 envelopes (input 1). OUTPUT: final contract envelope item(s). WHY: single workflow exit path without StopAndError."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "GUARD — Embed Has Model ID-id",
              "leftValue": "={{ $json.embedding_model_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "GUARD — Embed Has Model ID-active",
              "leftValue": "={{ $json.is_active === true }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            },
            {
              "id": "GUARD — Embed Has Model ID-dim",
              "leftValue": "={{ Number($json.output_dim || 0) }}",
              "rightValue": 1536,
              "operator": {
                "type": "number",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "ca09ea05-7dca-47e5-a43b-056a07daa08d",
      "name": "GUARD — Embed Has Model ID",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        160,
        1520
      ],
      "notes": "PURPOSE: Validate embedding model row exists and output_dim matches required 1536 for destination pgvector table. INPUT: merged model row + req context. OUTPUT TRUE: proceed to chunk embedding; FALSE: managed validation error to WF99. WHY: prevent invalid model or dimension mismatch writes."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "embedding_models",
          "mode": "list",
          "cachedResultName": "embedding_models"
        },
        "limit": 1,
        "where": {
          "values": [
            {
              "column": "id",
              "value": "={{ $json.embedding_model_id || $json.req?.job?.payload?.embedding_model_id }}"
            },
            {
              "column": "is_active",
              "value": "={{ true }}"
            }
          ]
        },
        "options": {}
      },
      "id": "570931e5-c89d-468e-9624-3737473ce45c",
      "name": "DB — Select Embedding Model",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2352,
        -240
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Load active embedding model by resolved embedding_model_id. INPUT: resolved model id + req context. OUTPUT: embedding model row (or empty item). WHY: embed_chunks requires provider/model_key/output_dim validation before API calls."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        },
        "where": {
          "values": [
            {
              "column": "document_id",
              "value": "={{ $json.req.job.payload.document_id }}"
            }
          ]
        },
        "options": {}
      },
      "id": "4a859a1e-ce77-4ac8-b54b-d775e38e0ef4",
      "name": "DB — Select Chunks For Embed",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        400,
        1360
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Load chunks for embed_chunks processing. INPUT: document_id. OUTPUT: chunk rows (or empty item when none). WHY: embed path source set."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "d57b4e31-d3c0-4459-97cb-63bf876f13ef",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "9362c693-f93b-4209-ad3c-e7e7e27bb467",
      "name": "GUARD — Has Chunks For Embed",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        704,
        1248
      ],
      "notes": "PURPOSE: Branch embed flow when chunk set is empty. INPUT: chunk query output. OUTPUT TRUE: embed path, FALSE: skipped no_chunks success. WHY: required edge behavior."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "df31b8e9-e488-4771-a73c-d2e3243b487f",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "95d2dcf2-9e77-4ad9-8b3f-a43e2d8ecf8f",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "0102a141-5bb5-4d5d-b79e-43f0ed9af773",
              "name": "data.document_id",
              "value": "={{ $json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "5b703f72-74cb-4cb1-84ec-17ed0bf98b1f",
              "name": "data.embedding_model_id",
              "value": "={{ $json.req.job.payload.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "5212f625-c0ea-45bb-b31f-c6b98a30dba0",
              "name": "data.skipped",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "d0f6dfad-e278-49f4-bb95-bef13d2a95db",
              "name": "data.reason",
              "value": "no_chunks",
              "type": "string"
            },
            {
              "id": "8360af28-cc57-486f-80cc-f06a39bf07ec",
              "name": "error",
              "value": null,
              "type": "object"
            },
            {
              "id": "f4832f8d-a832-437d-9534-0887485bc13f",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "5f8f714a-49e0-4b14-b733-9ec98a70f915",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "cfd3e3a9-1568-4cea-9e14-a7f763badf3a",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "7f09997b-cdf3-4f97-9142-ed622226f75d",
              "name": "meta.correlation.trace_id",
              "value": "={{ $json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "d461b18a-fc8b-4cfd-8f1f-d70ecb7af758",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "333f539a-1250-4cd1-b242-7e1f23079857",
              "name": "meta.correlation.chat_id",
              "value": "={{ $json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "79de8d93-0bd1-43c8-bbc9-2288166eb4d2",
              "name": "meta.correlation.message_id",
              "value": "={{ $json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "ba9d80cc-ca58-42f5-ad3b-718e705fffdc",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "0738d7d0-2781-4b67-a6cb-f12c1a265ecb",
              "name": "meta.correlation.node",
              "value": "GUARD — Has Chunks For Embed",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "10af0e42-900b-4776-9273-c98fe0609bb9",
      "name": "OUT — Success No Chunks",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1792,
        1392
      ],
      "notes": "PURPOSE: Return SuccessEnvelope skipped=no_chunks for embed path. INPUT: no chunk branch. OUTPUT: contract envelope. WHY: required embed edge case."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7f5ea860-f4f4-4fa5-a7e6-f4d91d73566b",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "47fb7fa2-bf4f-45e2-9fb9-876bf143935e",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "5cf67bde-0f44-42ca-8e6a-60151366cae7",
              "name": "data.document_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "260f8c0a-67eb-4f90-b6db-04d5ac277f8a",
              "name": "data.embedding_model_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "38ad9a01-6a2d-4728-a6a2-ab51f4201d23",
              "name": "data.embedded_count",
              "value": "={{ $(\"DB — Upsert Embedding\").all().length }}",
              "type": "number"
            },
            {
              "id": "ba1ca6a4-a6be-40f2-8362-dc8c7ff13d33",
              "name": "error",
              "value": null,
              "type": "object"
            },
            {
              "id": "2dc2e7df-4ad7-470d-9232-3cf7736f1210",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "ae818839-9ab9-4c85-96bc-41d2f7e88bce",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "d8dcaec6-d99e-4598-aa28-f4f9f5f66034",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "9af21071-fb2e-406a-b8be-edb6d6ad3e1d",
              "name": "meta.correlation.trace_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "b5eb5e64-21ff-4ec2-8f60-bfbb7c66ac9a",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "30b3af56-58cc-4833-9dc4-b13f8c4bc6f8",
              "name": "meta.correlation.chat_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "82439f34-a1a7-4fd7-af93-8c2f5e416111",
              "name": "meta.correlation.message_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "216408b9-5058-4f7d-b780-c3d38ab0f739",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "d8e66531-f28a-4d08-a258-0c4d85239c2d",
              "name": "meta.correlation.node",
              "value": "OUT — Success Embed",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "c0d20831-7237-4f7c-86ec-fcb356151458",
      "name": "OUT — Success Embed",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5280,
        1536
      ],
      "notes": "PURPOSE: Return SuccessEnvelope for embed_chunks happy path with real stats after full batched upsert loop. INPUT: SplitInBatches done output + accumulated upsert history. OUTPUT: document_id, embedding_model_id, embedded_count, correlation meta. WHY: WF41 worker output contract."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "wf41-if-embed-route",
              "leftValue": "={{ $json.req?.job?.job_type }}",
              "rightValue": "embed_chunks",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "c6da98a3-7fdf-4f38-ac6b-1d12d5991b1e",
      "name": "IF — Embed Route After Model Resolve",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        4064,
        816
      ],
      "notes": "PURPOSE: Split resolved embedding model flow by job_type. INPUT: Set — Select Embedding Model output. OUTPUT TRUE: embed_chunks path; FALSE: chunk_document enqueue path. WHY: shared model resolution node is reused by both branches."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "GUARD — Chunk Has Model ID-id",
              "leftValue": "={{ $json.embedding_model_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "GUARD — Chunk Has Model ID-active",
              "leftValue": "={{ $json.is_active === true }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            },
            {
              "id": "GUARD — Chunk Has Model ID-dim",
              "leftValue": "={{ Number($json.output_dim || 0) }}",
              "rightValue": 1536,
              "operator": {
                "type": "number",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "575c668d-772e-4526-8d12-8f195487d5fd",
      "name": "GUARD — Chunk Has Model ID",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        448,
        368
      ],
      "notes": "PURPOSE: Ensure chunk_document enqueue has resolved embedding_model_id. INPUT: resolved model selection output. OUTPUT TRUE: enqueue embed job; FALSE: managed validation error. WHY: prevents enqueue payload with null model id."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-bcfg-size",
              "name": "batch_size",
              "value": 50,
              "type": "number"
            },
            {
              "id": "wf41-bcfg-dim",
              "name": "expected_dim",
              "value": "={{ Number($(\"Set — Select Embedding Model\").item.json.output_dim || 1536) }}",
              "type": "number"
            },
            {
              "id": "wf41-bcfg-model",
              "name": "openai_model",
              "value": "={{ $(\"Set — Select Embedding Model\").item.json.model_key }}",
              "type": "string"
            },
            {
              "id": "wf41-bcfg-embed-id",
              "name": "embedding_model_id",
              "value": "={{ $(\"Set — Select Embedding Model\").item.json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "wf41-bcfg-req",
              "name": "req",
              "value": "={{ $(\"Set — Select Embedding Model\").item.json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-bcfg-ctx",
              "name": "ctx",
              "value": "={{ $(\"Set — Select Embedding Model\").item.json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-bcfg-job",
              "name": "job",
              "value": "={{ $(\"Set — Select Embedding Model\").item.json.job }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "6ff2a803-4703-4ace-bccd-c6b1305b0007",
      "name": "Set — Embed Batch Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1248,
        1184
      ],
      "notes": "PURPOSE: Configure embedding batch parameters and keep req context on each chunk item. INPUT: chunk row + model context. OUTPUT: batch_size, expected_dim, openai_model, embedding_model_id + context. WHY: consistent batch API calls and dimension validation."
    },
    {
      "parameters": {
        "batchSize": "={{ $json.batch_size || 50 }}",
        "options": {
          "reset": false
        }
      },
      "id": "3fded915-c8a0-441b-9aab-7968dc5a62c6",
      "name": "Split — Embed Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        4288,
        1680
      ],
      "notes": "PURPOSE: Iterate chunks in fixed-size groups for batched embeddings API calls. INPUT: chunk items with batch config. OUTPUT0: current batch; OUTPUT1: loop complete. WHY: required batched processing."
    },
    {
      "parameters": {
        "fieldsToAggregate": {
          "fieldToAggregate": [
            {
              "fieldToAggregate": "id"
            },
            {
              "fieldToAggregate": "text"
            },
            {
              "fieldToAggregate": "req"
            },
            {
              "fieldToAggregate": "ctx"
            },
            {
              "fieldToAggregate": "job"
            },
            {
              "fieldToAggregate": "embedding_model_id"
            },
            {
              "fieldToAggregate": "openai_model"
            },
            {
              "fieldToAggregate": "expected_dim"
            }
          ]
        },
        "options": {}
      },
      "id": "17df582a-586b-4d6d-97a8-9cc63bb16615",
      "name": "Aggregate — Embed Batch Inputs",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        4528,
        1968
      ],
      "notes": "PURPOSE: Collapse current SplitInBatches window into one item with arrays for chunk ids/texts. INPUT: one batch of chunk items. OUTPUT: aggregated arrays + carried context/model fields. WHY: OpenAI embeddings endpoint accepts array input."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-openai-ids",
              "name": "batch_chunk_ids",
              "value": "={{ Array.isArray($json.id) ? $json.id : [$json.id] }}",
              "type": "array"
            },
            {
              "id": "wf41-openai-texts",
              "name": "batch_texts",
              "value": "={{ (Array.isArray($json.text) ? $json.text : [$json.text]).map(v => String(v ?? \"\")) }}",
              "type": "array"
            },
            {
              "id": "wf41-openai-req",
              "name": "req",
              "value": "={{ Array.isArray($json.req) ? ($json.req[0] || null) : $json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-openai-ctx",
              "name": "ctx",
              "value": "={{ Array.isArray($json.ctx) ? ($json.ctx[0] || null) : $json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-openai-job",
              "name": "job",
              "value": "={{ Array.isArray($json.job) ? ($json.job[0] || null) : $json.job }}",
              "type": "object"
            },
            {
              "id": "wf41-openai-model",
              "name": "openai_model",
              "value": "={{ Array.isArray($json.openai_model) ? ($json.openai_model[0] || \"\") : ($json.openai_model || \"\") }}",
              "type": "string"
            },
            {
              "id": "wf41-openai-embedid",
              "name": "embedding_model_id",
              "value": "={{ Array.isArray($json.embedding_model_id) ? ($json.embedding_model_id[0] || null) : $json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "wf41-openai-dim",
              "name": "expected_dim",
              "value": "={{ Number(Array.isArray($json.expected_dim) ? ($json.expected_dim[0] || 1536) : ($json.expected_dim || 1536)) }}",
              "type": "number"
            },
            {
              "id": "wf41-openai-body-model",
              "name": "body.model",
              "value": "={{ Array.isArray($json.openai_model) ? ($json.openai_model[0] || \"\") : ($json.openai_model || \"\") }}",
              "type": "string"
            },
            {
              "id": "wf41-openai-body-input",
              "name": "body.input",
              "value": "={{ (Array.isArray($json.text) ? $json.text : [$json.text]).map(v => String(v ?? \"\")) }}",
              "type": "array"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "b51a8274-0211-44e2-941f-aa0d73fc4bfb",
      "name": "Set — Prepare OpenAI Batch Request",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1888,
        1872
      ],
      "notes": "PURPOSE: Prepare single-item OpenAI embeddings request payload for current batch. INPUT: aggregated batch arrays. OUTPUT: batch_chunk_ids, batch_texts, openai_model, expected_dim, embedding_model_id, req/ctx/job. WHY: clean request contract for HTTP node and carry/restore."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ $json.body }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 120000
        }
      },
      "id": "adfde378-cb71-4ad4-be9d-eeb9ab3f7e99",
      "name": "HTTP — OpenAI Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2224,
        1568
      ],
      "credentials": {
        "openAiApi": {
          "id": "LB6ntiMR8lDYKSy4",
          "name": "OpenAi account"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Call OpenAI batched embeddings API with array input. INPUT: openai_model + batch_texts. OUTPUT: JSON response with data[].embedding vectors. WHY: embed_chunks must generate vectors in batches."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "c892e3a2-7282-4a1d-b087-d8b0dd8ec57f",
      "name": "Merge — Restore CTX after HTTP Embeddings",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2528,
        1968
      ],
      "notes": "PURPOSE: Restore batch context after HTTP call. INPUT1: OpenAI response. INPUT2: prepared batch payload. OUTPUT: response + batch ids/texts/model/context. WHY: HTTP node output does not preserve full context."
    },
    {
      "parameters": {
        "jsCode": "const data = $json.data;\nconst ids = Array.isArray($json.batch_chunk_ids) ? $json.batch_chunk_ids : [];\nconst expectedDim = Number($json.expected_dim || 1536);\nif (!Array.isArray(data)) throw new Error('OpenAI embeddings response.data is not an array');\nif (data.length !== ids.length) throw new Error('OpenAI embeddings length mismatch with batch_chunk_ids');\nconst out = [];\nfor (let i = 0; i < ids.length; i++) {\n  const vec = data[i]?.embedding;\n  if (!Array.isArray(vec)) throw new Error('Embedding vector missing at index ' + i);\n  if (vec.length !== expectedDim) throw new Error('Embedding dimension mismatch at index ' + i + ': ' + vec.length + ' != ' + expectedDim);\n  out.push({\n    json: {\n      req: $json.req,\n      ctx: $json.ctx,\n      job: $json.job,\n      chunk_id: ids[i],\n      embedding_model_id: $json.embedding_model_id,\n      embedding_vec: vec,\n      embedding_len: vec.length,\n      expected_dim: expectedDim\n    }\n  });\n}\nreturn out;"
      },
      "id": "9e6973da-671f-4ff2-99a1-dd78668888ba",
      "name": "CODE — Expand Embeddings Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        1456
      ],
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Validate OpenAI response lengths/dimensions and fan out to one item per chunk. INPUT: batch ids + response.data embeddings + expected_dim. OUTPUT: one item per chunk with embedding_vec and context. WHY: deterministic mapping response index -> chunk_id."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-vec-str",
              "name": "embedding_str",
              "value": "={{ \"[\" + $json.embedding_vec.join(\",\") + \"]\" }}",
              "type": "string"
            },
            {
              "id": "wf41-vec-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-vec-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-vec-job",
              "name": "job",
              "value": "={{ $json.job }}",
              "type": "object"
            },
            {
              "id": "wf41-vec-chunk",
              "name": "chunk_id",
              "value": "={{ $json.chunk_id }}",
              "type": "number"
            },
            {
              "id": "wf41-vec-mid",
              "name": "embedding_model_id",
              "value": "={{ $json.embedding_model_id }}",
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "4939cc8c-b56e-4287-adc3-3e30aa2919fa",
      "name": "Set — Prepare Embedding Vector",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3584,
        1344
      ],
      "notes": "PURPOSE: Convert numeric vector array to pgvector string literal format for Postgres upsert. INPUT: embedding_vec per chunk. OUTPUT: embedding_str + chunk/model/context fields. WHY: pgvector column accepts string vector representation."
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunk_embeddings_1536",
          "mode": "list",
          "cachedResultName": "chunk_embeddings_1536"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "chunk_id": "={{ $json.chunk_id }}",
            "model_id": "={{ $json.embedding_model_id }}",
            "embedding": "={{ $json.embedding_str }}"
          },
          "matchingColumns": [
            "chunk_id",
            "model_id"
          ],
          "schema": [
            {
              "id": "chunk_id",
              "displayName": "chunk_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "model_id",
              "displayName": "model_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "embedding",
              "displayName": "embedding",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            }
          ]
        },
        "options": {}
      },
      "id": "7464e985-6b69-48a0-9981-3f2e278303c4",
      "name": "DB — Upsert Embedding",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3824,
        1360
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Upsert chunk embedding vector into kg.chunk_embeddings_1536 using PK (chunk_id, model_id). INPUT: chunk_id + embedding_model_id + embedding_str. OUTPUT: upsert result rows. WHY: idempotent persistence for embed_chunks."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Default Embed Model-node",
              "name": "_err.node",
              "value": "DB — Select Default Embedding Model",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Default Embed Model-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Default Embed Model-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "81596266-d0d7-478e-b40f-a67b845f3416",
      "name": "ERR — Source DB Default Embed Model",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4736,
        2704
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Select Default Embedding Model failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Embed Model-node",
              "name": "_err.node",
              "value": "DB — Select Embedding Model",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Embed Model-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Embed Model-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "eb828892-58ad-4762-a7cd-2bb5c18373d1",
      "name": "ERR — Source DB Embed Model",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4304,
        2832
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Select Embedding Model failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Embed Chunks-node",
              "name": "_err.node",
              "value": "DB — Select Chunks For Embed",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-table",
              "name": "_err.table",
              "value": "kg.chunks",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Embed Chunks-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Embed Chunks-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "201c2983-5dc8-4036-bbf4-04f0541b0cf1",
      "name": "ERR — Source DB Embed Chunks",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1360,
        2432
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Select Chunks For Embed failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-node",
              "name": "_err.node",
              "value": "HTTP — OpenAI Embeddings",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-op",
              "name": "_err.operation",
              "value": "post",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-table",
              "name": "_err.table",
              "value": "openai.v1.embeddings",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || $json.body?.error?.message || (\"OpenAI embeddings HTTP status \" + ($json.statusCode || 500)) }}",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-status",
              "name": "_err.status_code",
              "value": "={{ Number($json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "f865df7c-70b5-4ea8-a8c1-a40b6d6e2187",
      "name": "ERR — Source HTTP OpenAI Embeddings",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4512,
        2528
      ],
      "notes": "PURPOSE: Mark source metadata for HTTP — OpenAI Embeddings failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source CODE Expand Embeddings-node",
              "name": "_err.node",
              "value": "CODE — Expand Embeddings Batch",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-op",
              "name": "_err.operation",
              "value": "validate_embeddings",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-table",
              "name": "_err.table",
              "value": "batch",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-kind",
              "name": "_err.kind",
              "value": "={{ 'validation' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"OpenAI embedding response validation failed\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-status",
              "name": "_err.status_code",
              "value": "={{ 422 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "91ab5ab1-36a7-424d-bdc4-191c58b66999",
      "name": "ERR — Source CODE Expand Embeddings",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4624,
        2944
      ],
      "notes": "PURPOSE: Mark source metadata for CODE — Expand Embeddings Batch failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Upsert Embedding-node",
              "name": "_err.node",
              "value": "DB — Upsert Embedding",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-op",
              "name": "_err.operation",
              "value": "upsert",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-table",
              "name": "_err.table",
              "value": "kg.chunk_embeddings_1536",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "26216db8-e7d6-425c-9296-9b812d83a6fa",
      "name": "ERR — Source DB Upsert Embedding",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4496,
        2256
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Upsert Embedding failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source Embed Model Guard-node",
              "name": "_err.node",
              "value": "GUARD — Embed Has Model ID",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-op",
              "name": "_err.operation",
              "value": "validate_model",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-kind",
              "name": "_err.kind",
              "value": "={{ 'validation' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-msg",
              "name": "_err.message",
              "value": "={{ $json.id ? (\"Embedding dimension mismatch: expected 1536 got \" + $json.output_dim) : \"Embedding model not found or inactive\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-status",
              "name": "_err.status_code",
              "value": "={{ $json.id ? 422 : 404 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source Embed Model Guard-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source Embed Model Guard-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "e6c46e05-957f-403b-82b3-43513645ba2a",
      "name": "ERR — Source Embed Model Guard",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1088,
        2448
      ],
      "notes": "PURPOSE: Mark source metadata for GUARD — Embed Has Model ID failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source Chunk Model Guard-node",
              "name": "_err.node",
              "value": "GUARD — Chunk Has Model ID",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-op",
              "name": "_err.operation",
              "value": "validate_model",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-kind",
              "name": "_err.kind",
              "value": "={{ 'validation' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-msg",
              "name": "_err.message",
              "value": "={{ \"No active embedding model resolved for chunk_document enqueue\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-status",
              "name": "_err.status_code",
              "value": "={{ 422 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source Chunk Model Guard-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source Chunk Model Guard-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "f76187fc-eee9-494e-b366-f7fb1949e73c",
      "name": "ERR — Source Chunk Model Guard",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1712,
        3008
      ],
      "notes": "PURPOSE: Mark source metadata for GUARD — Chunk Has Model ID failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-kind",
              "name": "error_context.kind",
              "value": "={{ $json._err?.kind || \"unknown\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-msg",
              "name": "error_context.error_message",
              "value": "={{ $json._err?.message || $json.error?.message || $json.message || \"WF41 failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-status",
              "name": "error_context.status_code",
              "value": "={{ Number($json._err?.status_code || $json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-retry",
              "name": "error_context.retryable",
              "value": "={{ $json._err?.retryable !== undefined ? $json._err.retryable : false }}",
              "type": "boolean"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-node",
              "name": "error_context.node",
              "value": "={{ $json._err?.node || null }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-op",
              "name": "error_context.operation",
              "value": "={{ $json._err?.operation || null }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-table",
              "name": "error_context.table",
              "value": "={{ $json._err?.table || null }}",
              "type": "string"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-ctx",
              "name": "error_context.ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Prepare ErrorPipe v1 (Embed)-ctx-contract",
              "name": "ctx.contracts.errorpipe",
              "value": 1,
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "0ea68dba-569d-49af-bfe5-1f6c33a4248a",
      "name": "ERR — Prepare ErrorPipe v1 (Embed)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5152,
        2624
      ],
      "notes": "PURPOSE: Build ErrorPipe v1 payload for embed-path I/O and validation failures. INPUT: ERR — Source* item with _err metadata. OUTPUT: error_context.* + ctx.contracts.errorpipe=1 for WF99. WHY: centralized error envelope creation via WF99."
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gcM1ZRVCKVtzJfHOH7OTw",
          "mode": "list",
          "cachedResultUrl": "/workflow/gcM1ZRVCKVtzJfHOH7OTw",
          "cachedResultName": "WF99 — Global ERR Handler"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "af7c135c-c416-47bb-b328-dbaa1c2217b5",
      "name": "Execute WF99 (Embed)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        5392,
        2624
      ],
      "notes": "PURPOSE: Delegate embed-path errors to WF99 and return ErrorEnvelope. INPUT: ErrorPipe v1 payload. OUTPUT: WF99 ErrorEnvelope. WHY: project-wide centralized error handling."
    },
    {
      "parameters": {},
      "id": "86bfdda9-6824-4b49-91f7-68e01d31a516",
      "name": "Merge — Model Resolve Branches",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3520,
        208
      ],
      "notes": "PURPOSE: Join IF model-resolution branches via Merge (project branch-join rule). INPUT1: payload model path. INPUT2: default model lookup path. OUTPUT: single stream for Set — Select Embedding Model."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-doc-read-found",
              "name": "document_found",
              "value": "={{ $items('DB — Select Document').filter(i => i.json && i.json.id !== undefined && i.json.id !== null).length > 0 }}",
              "type": "boolean"
            },
            {
              "id": "wf41-doc-read-text",
              "name": "document_text",
              "value": "={{ (($items('DB — Select Document')[0] && $items('DB — Select Document')[0].json && $items('DB — Select Document')[0].json.text) || '') }}",
              "type": "string"
            },
            {
              "id": "wf41-doc-read-sha",
              "name": "stored_text_sha256",
              "value": "={{ (($items('DB — Select Document')[0] && $items('DB — Select Document')[0].json && $items('DB — Select Document')[0].json.text_sha256) || '') }}",
              "type": "string"
            },
            {
              "id": "wf41-doc-read-req",
              "name": "req",
              "value": "={{ $('Merge — Restore CTX after DB Document').item.json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-doc-read-ctx",
              "name": "ctx",
              "value": "={{ $('Merge — Restore CTX after DB Document').item.json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-doc-read-job",
              "name": "job",
              "value": "={{ $('Merge — Restore CTX after DB Document').item.json.job }}",
              "type": "object"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -176,
        144
      ],
      "id": "69f917c9-180f-4797-a0b7-1d6ceb480b7d",
      "name": "Set — Read Document Fields",
      "notes": "PURPOSE: Read document lookup output as side-data while keeping one spine item. INPUT: restored req/ctx spine + DB side lookup. OUTPUT: document_found, document_text, stored_text_sha256 + req/ctx/job. WHY: avoid 0-row dead ends from SELECT lookups."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "wf41-doc-found-cond",
              "leftValue": "={{ $json.document_found }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        48,
        144
      ],
      "id": "37fa3f30-d799-4bf0-be9f-820d9eb710ec",
      "name": "IF — Doc Found?",
      "notes": "PURPOSE: Ensure required document exists before chunking. INPUT: spine with document_found flag. OUTPUT TRUE: continue; FALSE: managed 404 to ErrorPipe. WHY: required lookup must fail explicitly, not silently."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-err-doc-node",
              "name": "_err.node",
              "value": "IF — Doc Found?",
              "type": "string"
            },
            {
              "id": "wf41-err-doc-op",
              "name": "_err.operation",
              "value": "validate_document",
              "type": "string"
            },
            {
              "id": "wf41-err-doc-table",
              "name": "_err.table",
              "value": "content.documents",
              "type": "string"
            },
            {
              "id": "wf41-err-doc-kind",
              "name": "_err.kind",
              "value": "validation",
              "type": "string"
            },
            {
              "id": "wf41-err-doc-msg",
              "name": "_err.message",
              "value": "Document not found",
              "type": "string"
            },
            {
              "id": "wf41-err-doc-status",
              "name": "_err.status_code",
              "value": 404,
              "type": "number"
            },
            {
              "id": "wf41-err-doc-retry",
              "name": "_err.retryable",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "wf41-err-doc-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-err-doc-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        672,
        2848
      ],
      "id": "4e09bcba-691b-409f-b916-44be1de4cc96",
      "name": "ERR — Source Document Not Found",
      "notes": "PURPOSE: Build managed 404 source metadata for missing document. INPUT: IF false branch. OUTPUT: _err.* + req/ctx for WF99 ErrorPipe. WHY: required lookup miss must be attributed and returned as ErrorEnvelope."
    },
    {
      "parameters": {
        "batchSize": 200,
        "options": {
          "reset": false
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        2528,
        -80
      ],
      "id": "3099dc03-a7e5-4469-a6cb-610827211570",
      "name": "Split — Chunk Upserts",
      "notes": "PURPOSE: Batch chunk upserts and emit one DONE branch after all chunk rows are written. INPUT: chunk item stream from chunk builder. OUTPUT 0: current batch for upsert loop; OUTPUT 1: done signal once. WHY: enqueue embed job exactly once after loop completion."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-enq-job-type",
              "name": "enqueue.job_type",
              "value": "embed_chunks",
              "type": "string"
            },
            {
              "id": "wf41-enq-tenant",
              "name": "enqueue.tenant_id",
              "value": "={{ $json.req.ctx.tenant_id }}",
              "type": "string"
            },
            {
              "id": "wf41-enq-correlation",
              "name": "enqueue.correlation_id",
              "value": "={{ $json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "wf41-enq-doc",
              "name": "enqueue.payload.document_id",
              "value": "={{ $json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "wf41-enq-model",
              "name": "enqueue.payload.embedding_model_id",
              "value": "={{ $json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "wf41-enq-force",
              "name": "enqueue.payload.force",
              "value": "={{ $json.req.job.payload.force === true }}",
              "type": "boolean"
            },
            {
              "id": "wf41-enq-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-enq-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-enq-job",
              "name": "job",
              "value": "={{ $json.job }}",
              "type": "object"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        864,
        320
      ],
      "id": "2612d109-9704-4188-80cb-0f68f4efbd65",
      "name": "Set — Prepare embed_chunks Job",
      "notes": "PURPOSE: Build enqueue payload with dotNotation (no object-literal). INPUT: validated model + req/ctx/job spine. OUTPUT: enqueue.* fields for select/insert. WHY: idempotent enqueue requires stable lookup and insert payload."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "ops",
          "mode": "list",
          "cachedResultName": "ops"
        },
        "table": {
          "__rl": true,
          "value": "jobs",
          "mode": "list",
          "cachedResultName": "jobs"
        },
        "limit": 1,
        "where": {
          "values": [
            {
              "column": "tenant_id",
              "value": "={{ $json.enqueue.tenant_id }}"
            },
            {
              "column": "job_type",
              "value": "embed_chunks"
            },
            {
              "column": "status",
              "value": "queued"
            },
            {
              "column": "correlation_id",
              "value": "={{ $json.enqueue.correlation_id }}"
            },
            {
              "column": "payload",
              "value": "={{ $json.enqueue.payload }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1168,
        288
      ],
      "id": "53dbaa02-5ea3-4956-b800-11f3be54717d",
      "name": "DB — Select Existing Embed Job",
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Prevent duplicate enqueue when reruns/retries happen. INPUT: enqueue keys from Set. OUTPUT: existing queued job row or empty item. WHY: ops.jobs has no unique key for this payload, so idempotency uses select-if-exists pattern."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "wf41-if-existing-enqueue",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1456,
        192
      ],
      "id": "220d11b3-45e3-41df-a0e6-583b673381d9",
      "name": "IF — Existing Embed Job?",
      "notes": "PURPOSE: Branch enqueue path by existing queued job presence. INPUT: select existing output. TRUE: skip insert; FALSE: insert once. WHY: enforce enqueue exactly once."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-mark-enqueued-true",
              "name": "embed_enqueued",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "wf41-mark-enqueued-req",
              "name": "req",
              "value": "={{ $(\"Set — Prepare embed_chunks Job\").item.json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-mark-enqueued-ctx",
              "name": "ctx",
              "value": "={{ $(\"Set — Prepare embed_chunks Job\").item.json.ctx }}",
              "type": "object"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2032,
        176
      ],
      "id": "383c4660-f824-428c-a0db-f0c488d2d9ec",
      "name": "Set — Mark Embed Enqueued",
      "notes": "PURPOSE: Tag success path where enqueue insert was performed. INPUT: DB enqueue success. OUTPUT: embed_enqueued=true with req/ctx spine. WHY: stable SuccessEnvelope semantics."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-mark-enqueued-false",
              "name": "embed_enqueued",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "wf41-mark-enqueued-false-req",
              "name": "req",
              "value": "={{ $(\"Set — Prepare embed_chunks Job\").item.json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-mark-enqueued-false-ctx",
              "name": "ctx",
              "value": "={{ $(\"Set — Prepare embed_chunks Job\").item.json.ctx }}",
              "type": "object"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1760,
        48
      ],
      "id": "4bd01bf8-4bfc-4a58-93a5-0de95c2d6400",
      "name": "Set — Mark Embed Already Enqueued",
      "notes": "PURPOSE: Tag success path where enqueue was skipped due to existing queued job. INPUT: IF existing true branch. OUTPUT: embed_enqueued=false with req/ctx spine. WHY: idempotent enqueue transparency."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "wf41-http-ok-status",
              "leftValue": "={{ Number($json.statusCode || 200) < 400 }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        3008,
        1552
      ],
      "id": "943aabf7-1375-4dbf-9ece-ee038f5b7db5",
      "name": "IF — OpenAI Status OK",
      "notes": "PURPOSE: Catch HTTP >=400 responses that may not route to error output in all n8n versions. INPUT: merged HTTP response + spine. TRUE: expand embeddings; FALSE: ErrorPipe. WHY: deterministic managed error routing for upstream failures."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Select Document-node",
              "name": "_err.node",
              "value": "DB — Select Document",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Document-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Document-table",
              "name": "_err.table",
              "value": "content.documents",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Document-kind",
              "name": "_err.kind",
              "value": "io",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Document-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || $json.message || \"WF41 I/O failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Document-status",
              "name": "_err.status_code",
              "value": "={{ Number($json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Select Document-retry",
              "name": "_err.retryable",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "ERR — Source DB Select Document-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Select Document-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        768,
        2208
      ],
      "id": "94261975-2f57-4ded-a9fa-fe92ea514c91",
      "name": "ERR — Source DB Select Document",
      "notes": "PURPOSE: Mark source metadata for DB — Select Document failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error output. OUTPUT: _err.* + req/ctx. WHY: per-node error attribution."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Probe Existing Chunks-node",
              "name": "_err.node",
              "value": "DB — Probe Existing Chunks",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-table",
              "name": "_err.table",
              "value": "kg.chunks",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-kind",
              "name": "_err.kind",
              "value": "io",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || $json.message || \"WF41 I/O failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-status",
              "name": "_err.status_code",
              "value": "={{ Number($json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-retry",
              "name": "_err.retryable",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Probe Existing Chunks-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1968,
        2528
      ],
      "id": "2880ef54-665f-40b3-a34d-eb7a52569fe4",
      "name": "ERR — Source DB Probe Existing Chunks",
      "notes": "PURPOSE: Mark source metadata for DB — Probe Existing Chunks failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error output. OUTPUT: _err.* + req/ctx. WHY: per-node error attribution."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Delete Old Chunks-node",
              "name": "_err.node",
              "value": "DB — Delete Old Chunks",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-op",
              "name": "_err.operation",
              "value": "delete",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-table",
              "name": "_err.table",
              "value": "kg.chunks",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-kind",
              "name": "_err.kind",
              "value": "io",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || $json.message || \"WF41 I/O failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-status",
              "name": "_err.status_code",
              "value": "={{ Number($json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-retry",
              "name": "_err.retryable",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Delete Old Chunks-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2624,
        2752
      ],
      "id": "d716154d-92e9-4d83-b114-c717c3fb2dac",
      "name": "ERR — Source DB Delete Old Chunks",
      "notes": "PURPOSE: Mark source metadata for DB — Delete Old Chunks failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error output. OUTPUT: _err.* + req/ctx. WHY: per-node error attribution."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Upsert Chunk-node",
              "name": "_err.node",
              "value": "DB — Upsert Chunk",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-op",
              "name": "_err.operation",
              "value": "upsert",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-table",
              "name": "_err.table",
              "value": "kg.chunks",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-kind",
              "name": "_err.kind",
              "value": "io",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || $json.message || \"WF41 I/O failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-status",
              "name": "_err.status_code",
              "value": "={{ Number($json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-retry",
              "name": "_err.retryable",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Upsert Chunk-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        5712,
        2288
      ],
      "id": "eb91ff8e-e05d-48bf-a263-de68c7347185",
      "name": "ERR — Source DB Upsert Chunk",
      "notes": "PURPOSE: Mark source metadata for DB — Upsert Chunk failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error output. OUTPUT: _err.* + req/ctx. WHY: per-node error attribution."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-node",
              "name": "_err.node",
              "value": "DB — Enqueue embed_chunks Job",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-op",
              "name": "_err.operation",
              "value": "insert",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-table",
              "name": "_err.table",
              "value": "ops.jobs",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-kind",
              "name": "_err.kind",
              "value": "io",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || $json.message || \"WF41 I/O failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-status",
              "name": "_err.status_code",
              "value": "={{ Number($json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-retry",
              "name": "_err.retryable",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Enqueue embed_chunks Job-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3824,
        2624
      ],
      "id": "03479865-a363-4f70-a6b9-0353f8527f58",
      "name": "ERR — Source DB Enqueue embed_chunks Job",
      "notes": "PURPOSE: Mark source metadata for DB — Enqueue embed_chunks Job failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error output. OUTPUT: _err.* + req/ctx. WHY: per-node error attribution."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Select Existing Embed Job-node",
              "name": "_err.node",
              "value": "DB — Select Existing Embed Job",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-table",
              "name": "_err.table",
              "value": "ops.jobs",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-kind",
              "name": "_err.kind",
              "value": "io",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || $json.message || \"WF41 I/O failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-status",
              "name": "_err.status_code",
              "value": "={{ Number($json.statusCode || $json.httpCode || 500) }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-retry",
              "name": "_err.retryable",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Select Existing Embed Job-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1936,
        2304
      ],
      "id": "0c1a3c72-0640-4275-99e6-882d6f2ba47b",
      "name": "ERR — Source DB Select Existing Embed Job",
      "notes": "PURPOSE: Mark source metadata for DB — Select Existing Embed Job failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error output. OUTPUT: _err.* + req/ctx. WHY: per-node error attribution."
    },
    {
      "id": "wf41-split-embedding-upserts",
      "name": "Split — Embedding Upserts",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        3808,
        1344
      ],
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "notes": "PURPOSE: Enforce one-by-one embedding upserts to prevent partial-batch success when any upsert fails. INPUT: prepared embedding items for one OpenAI batch. OUTPUT 0: single item to DB — Upsert Embedding loop; OUTPUT 1: batch done signal back to Split — Embed Batches. WHY: guarantees WF99 error path wins on first failing upsert."
    }
  ],
  "pinData": {},
  "connections": {
    "IN — Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Merge — IN (WF90 + TEST)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TEST — Manual Trigger": {
      "main": [
        [
          {
            "node": "TEST — Build Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TEST — Build Requests": {
      "main": [
        [
          {
            "node": "Merge — IN (WF90 + TEST)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge — IN (WF90 + TEST)": {
      "main": [
        [
          {
            "node": "Set — Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Normalize Input": {
      "main": [
        [
          {
            "node": "GUARD — Preflight Input",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge — Restore CTX after DB Document",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "GUARD — Preflight Input": {
      "main": [
        [
          {
            "node": "SWITCH — Route job_type",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SWITCH — Route job_type": {
      "main": [
        [
          {
            "node": "DB — Select Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "IF — Payload Has Embedding Model",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Document": {
      "main": [
        [
          {
            "node": "Merge — Restore CTX after DB Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Select Document",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Restore CTX after DB Document": {
      "main": [
        [
          {
            "node": "Set — Read Document Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Document Has Text": {
      "main": [
        [
          {
            "node": "Crypto — Hash Document Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success Empty Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Crypto — Hash Document Text": {
      "main": [
        [
          {
            "node": "DB — Probe Existing Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Probe Existing Chunks": {
      "main": [
        [
          {
            "node": "Set — Decide Rechunk",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Probe Existing Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Decide Rechunk": {
      "main": [
        [
          {
            "node": "IF — Needs Rechunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Needs Rechunk": {
      "main": [
        [
          {
            "node": "DB — Delete Old Chunks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success Already Chunked",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Delete Old Chunks": {
      "main": [
        [
          {
            "node": "CODE — Build Chunks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Delete Old Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CODE — Build Chunks": {
      "main": [
        [
          {
            "node": "Split — Chunk Upserts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Crypto — Hash Chunk": {
      "main": [
        [
          {
            "node": "Set — Prepare Chunk Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Prepare Chunk Row": {
      "main": [
        [
          {
            "node": "DB — Upsert Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Upsert Chunk": {
      "main": [
        [
          {
            "node": "Split — Chunk Upserts",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Upsert Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Payload Has Embedding Model": {
      "main": [
        [
          {
            "node": "DB — Select Embedding Model",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DB — Select Default Embedding Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Default Embedding Model": {
      "main": [
        [
          {
            "node": "Merge — Model Resolve Branches",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "ERR — Source DB Default Embed Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Select Embedding Model": {
      "main": [
        [
          {
            "node": "IF — Embed Route After Model Resolve",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Enqueue embed_chunks Job": {
      "main": [
        [
          {
            "node": "Set — Mark Embed Enqueued",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Enqueue embed_chunks Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source Input Guard": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Prepare ErrorPipe v1 (Input)": {
      "main": [
        [
          {
            "node": "Execute WF99 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute WF99 (Input)": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "OUT — Success Empty Text": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Embed Has Model ID": {
      "main": [
        [
          {
            "node": "DB — Select Chunks For Embed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Embed Model Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Embedding Model": {
      "main": [
        [
          {
            "node": "Merge — Model Resolve Branches",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Embed Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Chunks For Embed": {
      "main": [
        [
          {
            "node": "GUARD — Has Chunks For Embed",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Embed Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Has Chunks For Embed": {
      "main": [
        [
          {
            "node": "Set — Embed Batch Config",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success No Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Embed Route After Model Resolve": {
      "main": [
        [
          {
            "node": "GUARD — Embed Has Model ID",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "GUARD — Chunk Has Model ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Chunk Has Model ID": {
      "main": [
        [
          {
            "node": "Set — Prepare embed_chunks Job",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Chunk Model Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Embed Batch Config": {
      "main": [
        [
          {
            "node": "Split — Embed Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split — Embed Batches": {
      "main": [
        [
          {
            "node": "Aggregate — Embed Batch Inputs",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success Embed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate — Embed Batch Inputs": {
      "main": [
        [
          {
            "node": "Set — Prepare OpenAI Batch Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Prepare OpenAI Batch Request": {
      "main": [
        [
          {
            "node": "HTTP — OpenAI Embeddings",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge — Restore CTX after HTTP Embeddings",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "HTTP — OpenAI Embeddings": {
      "main": [
        [
          {
            "node": "Merge — Restore CTX after HTTP Embeddings",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source HTTP OpenAI Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Restore CTX after HTTP Embeddings": {
      "main": [
        [
          {
            "node": "IF — OpenAI Status OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CODE — Expand Embeddings Batch": {
      "main": [
        [
          {
            "node": "Set — Prepare Embedding Vector",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source CODE Expand Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Prepare Embedding Vector": {
      "main": [
        [
          {
            "node": "Split — Embedding Upserts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Upsert Embedding": {
      "main": [
        [
          {
            "node": "Split — Embedding Upserts",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Upsert Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Default Embed Model": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Embed Model": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Embed Chunks": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source HTTP OpenAI Embeddings": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source CODE Expand Embeddings": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Upsert Embedding": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source Embed Model Guard": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source Chunk Model Guard": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Prepare ErrorPipe v1 (Embed)": {
      "main": [
        [
          {
            "node": "Execute WF99 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute WF99 (Embed)": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "OUT — Success Chunk": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OUT — Success Already Chunked": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OUT — Success No Chunks": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OUT — Success Embed": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Model Resolve Branches": {
      "main": [
        [
          {
            "node": "Set — Select Embedding Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Read Document Fields": {
      "main": [
        [
          {
            "node": "IF — Doc Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Doc Found?": {
      "main": [
        [
          {
            "node": "GUARD — Document Has Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Document Not Found",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source Document Not Found": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split — Chunk Upserts": {
      "main": [
        [
          {
            "node": "Crypto — Hash Chunk",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "IF — Payload Has Embedding Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Select Document": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Probe Existing Chunks": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Delete Old Chunks": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Upsert Chunk": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Enqueue embed_chunks Job": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Select Existing Embed Job": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Prepare embed_chunks Job": {
      "main": [
        [
          {
            "node": "DB — Select Existing Embed Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Existing Embed Job": {
      "main": [
        [
          {
            "node": "IF — Existing Embed Job?",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Select Existing Embed Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Existing Embed Job?": {
      "main": [
        [
          {
            "node": "Set — Mark Embed Already Enqueued",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DB — Enqueue embed_chunks Job",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Mark Embed Enqueued": {
      "main": [
        [
          {
            "node": "OUT — Success Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Mark Embed Already Enqueued": {
      "main": [
        [
          {
            "node": "OUT — Success Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — OpenAI Status OK": {
      "main": [
        [
          {
            "node": "CODE — Expand Embeddings Batch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source HTTP OpenAI Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split — Embedding Upserts": {
      "main": [
        [
          {
            "node": "DB — Upsert Embedding",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Split — Embed Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "06baf03b-42bd-4c10-944f-94fef683c822",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "49b1b765c7a60d5365a95e5c3e2d1b2e695b21e61861bbe488c27ec04546a71d"
  },
  "id": "mRsYUkeg_hP-L6kzvpjis",
  "tags": []
}
