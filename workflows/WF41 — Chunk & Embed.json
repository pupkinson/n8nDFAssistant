{
  "name": "WF41 — Chunk & Embed",
  "nodes": [
    {
      "parameters": {
        "inputSource": "passthrough"
      },
      "id": "2b425ac3-8f42-4c94-b971-b5b8693ce8a3",
      "name": "IN — Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1.1,
      "position": [
        -1760,
        1040
      ],
      "notes": "PURPOSE: Worker entry from WF90 Execute Workflow. INPUT: single item with req{ctx,job}. OUTPUT: raw worker request. WHY: canonical worker trigger."
    },
    {
      "parameters": {},
      "id": "6f86ee7b-a008-47e4-b5ac-fdf9df5bf8f4",
      "name": "TEST — Manual Trigger",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1760,
        1472
      ],
      "notes": "PURPOSE: Run DB-backed T1/T2/T3 tests inside WF41. INPUT: manual click. OUTPUT: test requests merged into main pipeline. WHY: required regression checks."
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      req: {\n        ctx: {\n          tenant_id: '00000000-0000-0000-0000-000000000041',\n          correlation_id: '41000000-0000-0000-0000-000000000001',\n          trace_id: null,\n          chat_id: null,\n          message_id: null,\n          workflow: 'WF90',\n          job_id: 410001\n        },\n        job: {\n          id: 410001,\n          job_type: 'chunk_document',\n          payload: {\n            document_id: 410001,\n            strategy: 'default'\n          }\n        }\n      },\n      _test: { id: 'T1', expect: 'happy' }\n    }\n  },\n  {\n    json: {\n      req: {\n        ctx: {\n          tenant_id: '00000000-0000-0000-0000-000000000041',\n          correlation_id: '41000000-0000-0000-0000-000000000002',\n          trace_id: null,\n          chat_id: null,\n          message_id: null,\n          workflow: 'WF90',\n          job_id: 410002\n        },\n        job: {\n          id: 410002,\n          job_type: 'chunk_document',\n          payload: {\n            document_id: 410002,\n            strategy: 'default'\n          }\n        }\n      },\n      _test: { id: 'T2', expect: 'empty_text' }\n    }\n  },\n  {\n    json: {\n      req: {\n        ctx: {\n          tenant_id: '00000000-0000-0000-0000-000000000041',\n          correlation_id: '41000000-0000-0000-0000-000000000003',\n          trace_id: null,\n          chat_id: null,\n          message_id: null,\n          workflow: 'WF90',\n          job_id: 410003\n        },\n        job: {\n          id: 410003,\n          job_type: 'chunk_document',\n          payload: {\n            document_id: 999999999\n          }\n        }\n      },\n      _test: { id: 'T3', expect: 'wf99_error' }\n    }\n  }\n];"
      },
      "id": "836d43dc-b757-4b9a-83fc-a91ff35b159a",
      "name": "TEST — Build Requests",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1520,
        1472
      ],
      "notes": "PURPOSE: Emit three required test requests (T1/T2/T3) that reuse production pipeline. INPUT: manual trigger. OUTPUT: items with req.ctx/req.job. WHY: deterministic test harness."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "passThrough"
      },
      "id": "1cb9ce68-dd00-47ed-9f1c-0212d17aaf35",
      "name": "Merge — IN (WF90 + TEST)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1280,
        1040
      ],
      "notes": "PURPOSE: Unify WF90 runtime input and manual test input. INPUT1: trigger. INPUT2: test requests. OUTPUT: one canonical stream. WHY: tests must reuse core logic, no mock branch."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a4f9f3a5-c342-4aa7-8618-24f33f4a02b2",
              "name": "req.ctx",
              "value": "={{ $json.req?.ctx ?? $json.ctx ?? {} }}",
              "type": "object"
            },
            {
              "id": "a4f9f3a5-c342-4aa7-8618-24f33f4a02b3",
              "name": "req.job",
              "value": "={{ $json.req?.job ?? $json.job ?? {} }}",
              "type": "object"
            },
            {
              "id": "8c7f7f9a-12d9-4c21-ac3a-8253126ea7f6",
              "name": "ctx",
              "value": "={{ $json.req?.ctx ?? $json.ctx ?? {} }}",
              "type": "object"
            },
            {
              "id": "3a36975b-87dd-4708-af79-7377e2b66d75",
              "name": "job",
              "value": "={{ $json.req?.job ?? $json.job ?? {} }}",
              "type": "object"
            },
            {
              "id": "d1578f59-4b0f-4f0e-8fc1-ae3c8e8d4f5d",
              "name": "ctx.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "c61f9fe6-2af4-4986-b6aa-2e616a8a9c66",
              "name": "ctx.contracts.errorpipe",
              "value": 1,
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "751de9ac-6338-4b88-a7d1-0d7184199029",
      "name": "Set — Normalize Input",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1040,
        1040
      ],
      "notes": "PURPOSE: Normalize WF90 request contract for worker execution. INPUT: either {req:{ctx,job}} or {ctx,job} (both forms accepted). OUTPUT: req.ctx + req.job + ctx + job canonical fields. WHY: all downstream nodes expect stable $json.req.* structure; dual input format for caller flexibility."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "0f4048f3-4bbf-422c-94b8-38e4958db895",
              "leftValue": "={{ $json.req?.ctx }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "ed74cc42-a5bc-4f5f-a7f1-a4b7dcfd2d1e",
              "leftValue": "={{ $json.req?.job }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "cbf41d09-0aa8-4fb9-b76e-b8c3f4fc2ab0",
              "leftValue": "={{ $json.req?.job?.payload?.document_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "4607d4c2-4c94-4478-8427-03532b594dbc",
      "name": "GUARD — Preflight Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -784,
        1200
      ],
      "notes": "PURPOSE: Validate req.ctx, req.job, and payload.document_id before routing. INPUT: normalized request. OUTPUT TRUE: valid; FALSE: managed validation error. WHY: Step 0 preflight requirement."
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "version": 3
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.req?.job?.job_type }}",
                    "rightValue": "chunk_document",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "f7f93bda-53cb-4454-bb0e-f89e1a2d57ad"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "chunk_document"
            },
            {
              "conditions": {
                "options": {
                  "version": 3
                },
                "combinator": "and",
                "conditions": [
                  {
                    "leftValue": "={{ $json.req?.job?.job_type }}",
                    "rightValue": "embed_chunks",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "e97ae48d-ad4a-4ef0-a981-1826e7f80e3f"
                  }
                ]
              },
              "renameOutput": true,
              "outputKey": "embed_chunks"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "a3784a3d-ead5-408f-9ff4-700c24d80cf2",
      "name": "SWITCH — Route job_type",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -544,
        992
      ],
      "notes": "PURPOSE: Route execution to chunk_document or embed_chunks path. INPUT: validated req/job. OUTPUTS: chunk_document, embed_chunks, fallback. WHY: strict worker dispatch by ops.job_type."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "content",
          "mode": "list",
          "cachedResultName": "content"
        },
        "table": {
          "__rl": true,
          "value": "documents",
          "mode": "list",
          "cachedResultName": "documents"
        },
        "where": {
          "values": [
            {
              "column": "id",
              "value": "={{ $json.req.job.payload.document_id }}"
            },
            {
              "column": "tenant_id",
              "value": "={{ $json.req.ctx.tenant_id }}"
            }
          ]
        },
        "options": {}
      },
      "id": "b198ee20-54dc-4409-8010-b4d05103b511",
      "name": "DB — Select Document",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -272,
        896
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Load content.documents by tenant_id + document_id for chunking and embedding. INPUT: req.ctx + req.job.payload.document_id. OUTPUT: document row. WHY: authoritative source text/status/hash."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "5aff3abb-a824-4d49-9b28-245a4624526c",
      "name": "Merge — Restore CTX after DB Document",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -80,
        736
      ],
      "notes": "PURPOSE: Carry/restore req, ctx, and job after Postgres select overwrite. INPUT1: DB row. INPUT2: pre-DB item. OUTPUT: document + req/ctx/job. WHY: mandatory carry pattern after I/O."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "25727870-40e3-49c2-ae54-5c916d3a4221",
              "leftValue": "={{ ($json.text || '').trim() }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "f296def5-5dde-4415-8f0a-b0ce80a9674f",
      "name": "GUARD — Document Has Text",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        160,
        656
      ],
      "notes": "PURPOSE: Skip chunking when document text is empty/whitespace. INPUT: loaded document. OUTPUT TRUE: chunkable text; FALSE: success skipped empty_text. WHY: required Step A.2 guard."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "5c6f9f34-57d1-459d-8d0f-bc8b475a3f0e",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "7f4bb778-cc03-4900-b302-a16dc64fd070",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "f1baf875-cfc8-4f15-947d-f70435f47c38",
              "name": "data.document_id",
              "value": "={{ $json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "740f93f7-2f85-4fcb-a2c1-3f5a1030485f",
              "name": "data.skipped",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "37020da8-8b0e-4e3a-8bf7-0671de3f1508",
              "name": "data.reason",
              "value": "empty_text",
              "type": "string"
            },
            {
              "id": "cc616176-b6fe-47bb-bb85-9df66469d76b",
              "name": "error",
              "value": null,
              "type": "string"
            },
            {
              "id": "97bf7a1d-f60b-4bb6-b168-f31f326f0990",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "7885eae8-24b2-4380-b2d6-452d46f8356e",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "5d8f1bad-1597-4465-8eec-a4986f4b4ba8",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "9f8bbf84-8e49-42ac-b77f-8c7b9305b670",
              "name": "meta.correlation.trace_id",
              "value": "={{ $json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "f84fbf11-af5e-4491-b6db-73caec53f90f",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "b4ba2ffc-ef66-48fc-ad65-2f81f082a549",
              "name": "meta.correlation.chat_id",
              "value": "={{ $json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "3dceeb67-5cf8-44c0-9838-95f773be1010",
              "name": "meta.correlation.message_id",
              "value": "={{ $json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "a9f71be0-36fa-42bc-a39e-3f1ccfe83d0d",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "9bb8f1b1-a36b-4656-ab65-4ecd89f7b92a",
              "name": "meta.correlation.node",
              "value": "GUARD — Document Has Text",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "4000ae89-56f8-4a69-b8cf-1da08b2d71a5",
      "name": "OUT — Success Empty Text",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1120,
        992
      ],
      "notes": "PURPOSE: Return SuccessEnvelope for empty text without enqueueing embed job. INPUT: text guard false. OUTPUT: ok=true skipped=empty_text. WHY: required non-error skip behavior."
    },
    {
      "parameters": {
        "value": "={{ $json.text }}",
        "dataPropertyName": "text"
      },
      "id": "3e5491f7-4464-4228-b4df-23f7932893ec",
      "name": "Crypto — Hash Document Text",
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        400,
        560
      ],
      "notes": "PURPOSE: Compute SHA256 for current document text. INPUT: document.text. OUTPUT: hash hex. WHY: idempotency and document.text_sha256 maintenance."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        },
        "limit": 1,
        "where": {
          "values": [
            {
              "column": "document_id",
              "value": "={{ $json.req.job.payload.document_id }}"
            }
          ]
        },
        "options": {}
      },
      "id": "d7f0785f-3f5a-45ab-8b8e-d04190db4239",
      "name": "DB — Probe Existing Chunks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        640,
        560
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Probe whether chunks already exist for document_id. INPUT: document_id. OUTPUT: first chunk row or none. WHY: idempotency decision before rechunking."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8b16804a-fad7-4f27-bdcf-c94eec4b0b6f",
              "name": "doc_hash_hex",
              "value": "={{ $('Crypto — Hash Document Text').item.json.hash }}",
              "type": "string"
            },
            {
              "id": "6e4ec801-2989-4675-8d1f-f7577b37919b",
              "name": "doc_hash_bytea",
              "value": "={{ '\\\\x' + $('Crypto — Hash Document Text').item.json.hash }}",
              "type": "string"
            },
            {
              "id": "2e6512f7-c912-486e-bdc5-7c5cc6118a9a",
              "name": "has_chunks",
              "value": "={{ !!$json.id }}",
              "type": "boolean"
            },
            {
              "id": "f024e4c9-5639-4fdb-aaf3-4de4ea335774",
              "name": "old_hash",
              "value": "={{ (($('Merge — Restore CTX after DB Document').item.json.text_sha256 || '') + '').replace('\\\\x','') }}",
              "type": "string"
            },
            {
              "id": "addfeacb-a482-4b35-b393-2b7d744de2cf",
              "name": "needs_rechunk",
              "value": "={{ $json.req.job.payload.force === true || !($json.id) || ((($('Merge — Restore CTX after DB Document').item.json.text_sha256 || '') + '').replace('\\\\x','') !== $('Crypto — Hash Document Text').item.json.hash) }}",
              "type": "boolean"
            },
            {
              "id": "a6f34f54-b410-497e-a9f6-a68f8f8913f4",
              "name": "text",
              "value": "={{ $('Merge — Restore CTX after DB Document').item.json.text }}",
              "type": "string"
            },
            {
              "id": "04f0ff43-4ba9-4531-827e-7e8e0dbf71e8",
              "name": "req",
              "value": "={{ $('Merge — Restore CTX after DB Document').item.json.req }}",
              "type": "object"
            },
            {
              "id": "3a7f7be5-f028-4496-a886-3c3ea42cd7d4",
              "name": "ctx",
              "value": "={{ $('Merge — Restore CTX after DB Document').item.json.ctx }}",
              "type": "object"
            },
            {
              "id": "852cb9ce-8776-4706-8efe-273fa63d745e",
              "name": "job",
              "value": "={{ $('Merge — Restore CTX after DB Document').item.json.job }}",
              "type": "object"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "23e68010-df4d-4b60-b091-45ee34e7567d",
      "name": "Set — Decide Rechunk",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        880,
        496
      ],
      "notes": "PURPOSE: Build hash/idempotency state and carry context. INPUT: hash + chunk probe + document row. OUTPUT: needs_rechunk, hashes, req/ctx/job/text. WHY: controlled branch for stale/fresh chunks."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "f843f0f5-966f-4f82-9892-9c0d282db986",
              "leftValue": "={{ $json.needs_rechunk }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "d75a0325-6751-42b0-b8c9-86d47172e659",
      "name": "IF — Needs Rechunk",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1120,
        528
      ],
      "notes": "PURPOSE: Skip expensive rechunk when current hash already chunked. INPUT: idempotency state. OUTPUT TRUE: rechunk; FALSE: already_chunked success. WHY: idempotent worker behavior."
    },
    {
      "parameters": {
        "operation": "delete",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        }
      },
      "id": "f5a9a2e9-aa20-49cb-ba9c-952e08de32e3",
      "name": "DB — Delete Old Chunks",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1360,
        560
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Remove stale chunks for document before rewrite. INPUT: document_id. OUTPUT: delete result. WHY: stale data cleanup; embeddings cascade via FK ON DELETE CASCADE."
    },
    {
      "parameters": {
        "jsCode": "const txt = ($json.text || '').toString();\nconst strategy = ($json.req?.job?.payload?.strategy || 'default').toLowerCase();\nlet size = 1200;\nlet overlap = 120;\nif (strategy === 'small') { size = 700; overlap = 80; }\nif (strategy === 'large') { size = 1800; overlap = 180; }\nconst out = [];\nif (!txt.trim()) return [];\nlet i = 0;\nlet no = 0;\nwhile (i < txt.length) {\n  const end = Math.min(txt.length, i + size);\n  const chunkText = txt.slice(i, end);\n  out.push({ json: {\n    req: $json.req,\n    ctx: $json.ctx,\n    job: $json.job,\n    document_id: $json.req.job.payload.document_id,\n    embedding_model_id: $json.req.job.payload.embedding_model_id || null,\n    doc_hash_hex: $json.doc_hash_hex,\n    doc_hash_bytea: $json.doc_hash_bytea,\n    chunk_no: no,\n    char_start: i,\n    char_end: end,\n    chunk_text: chunkText\n  }});\n  if (end >= txt.length) break;\n  i = Math.max(end - overlap, i + 1);\n  no += 1;\n}\nreturn out;"
      },
      "id": "ec88ec5c-69e3-494c-ad15-df935e9429fb",
      "name": "CODE — Build Chunks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1616,
        496
      ],
      "notes": "PURPOSE: Split text into chunk items with strategy-aware size/overlap. INPUT: text + req + hash state. OUTPUT: one item per chunk with positions. WHY: no splitter node in repo examples; controlled deterministic chunking."
    },
    {
      "parameters": {
        "value": "={{ $json.chunk_text }}",
        "dataPropertyName": "chunk_text"
      },
      "id": "7891c409-7486-420a-b948-dccbdfd297a9",
      "name": "Crypto — Hash Chunk",
      "type": "n8n-nodes-base.crypto",
      "typeVersion": 1,
      "position": [
        1840,
        560
      ],
      "notes": "PURPOSE: Compute SHA256 for each chunk text. INPUT: chunk_text. OUTPUT: hash hex. WHY: chunk-level idempotency metadata."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "8f35993f-8d83-40f0-be8b-c4ed98d3f3af",
              "name": "meta.chunk_sha256",
              "value": "={{ $json.hash }}",
              "type": "string"
            },
            {
              "id": "1bc6dc79-2fa8-4bc6-8841-6ea6b6659653",
              "name": "meta.document_sha256",
              "value": "={{ $json.doc_hash_hex }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "d5732b42-d661-4c3f-ae04-8896fdf8c9fd",
      "name": "Set — Prepare Chunk Row",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2080,
        560
      ],
      "notes": "PURPOSE: Build kg.chunks row payload with meta hashes. INPUT: hashed chunk item. OUTPUT: chunk fields + meta.*. WHY: align with SQL schema and upsert key."
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "document_id": "={{ $json.document_id }}",
            "chunk_no": "={{ $json.chunk_no }}",
            "char_start": "={{ $json.char_start }}",
            "char_end": "={{ $json.char_end }}",
            "text": "={{ $json.chunk_text }}",
            "meta": "={{ $json.meta }}"
          },
          "matchingColumns": [
            "document_id",
            "chunk_no"
          ],
          "schema": [
            {
              "id": "document_id",
              "displayName": "document_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "chunk_no",
              "displayName": "chunk_no",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "char_start",
              "displayName": "char_start",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": false
            },
            {
              "id": "char_end",
              "displayName": "char_end",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": false
            },
            {
              "id": "text",
              "displayName": "text",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "meta",
              "displayName": "meta",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": false
            }
          ]
        },
        "options": {}
      },
      "id": "5fcba9c7-a012-45ac-a1e7-3ded7dcb5683",
      "name": "DB — Upsert Chunk",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2320,
        560
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Upsert chunk rows into kg.chunks on unique(document_id,chunk_no). INPUT: chunk row payload. OUTPUT: upsert result. WHY: idempotent chunk persistence without SQL query node."
    },
    {
      "parameters": {
        "schema": {
          "__rl": true,
          "value": "ops",
          "mode": "list",
          "cachedResultName": "ops"
        },
        "table": {
          "__rl": true,
          "value": "jobs",
          "mode": "list",
          "cachedResultName": "jobs"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "tenant_id": "={{ $('Set — Decide Rechunk').item.json.req.ctx.tenant_id }}",
            "job_type": "embed_chunks",
            "payload": "={{ { document_id: $('Set — Decide Rechunk').item.json.req.job.payload.document_id, embedding_model_id: $('Set — Select Embedding Model').item.json.embedding_model_id } }}",
            "correlation_id": "={{ $('Set — Decide Rechunk').item.json.req.ctx.correlation_id }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "tenant_id",
              "displayName": "tenant_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "job_type",
              "displayName": "job_type",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "options",
              "canBeUsedToMatch": true,
              "options": [
                {
                  "name": "embed_chunks",
                  "value": "embed_chunks"
                }
              ]
            },
            {
              "id": "payload",
              "displayName": "payload",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "object",
              "canBeUsedToMatch": true
            },
            {
              "id": "correlation_id",
              "displayName": "correlation_id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            }
          ]
        },
        "options": {}
      },
      "id": "9f6a5af8-7326-4502-b294-826302ad350c",
      "name": "DB — Enqueue embed_chunks Job",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3040,
        560
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Enqueue follow-up embed_chunks job in ops.jobs. INPUT: tenant_id, document_id, selected embedding_model_id, correlation_id. OUTPUT: inserted job row. WHY: decouple chunking and embedding workers."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "bd4bfce4-b360-4fa7-a38d-74dbf01cc0f5",
              "name": "embedding_model_id",
              "value": "={{ $json.req?.job?.payload?.embedding_model_id || $json.id || $json.embedding_model_id || null }}",
              "type": "number"
            },
            {
              "id": "wf41-setsel-req-model",
              "name": "req.job.payload.embedding_model_id",
              "value": "={{ $json.req?.job?.payload?.embedding_model_id || $json.id || $json.embedding_model_id || null }}",
              "type": "number"
            },
            {
              "id": "wf41-setsel-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "wf41-setsel-job",
              "name": "job",
              "value": "={{ $json.job || $json.req?.job || {} }}",
              "type": "object"
            },
            {
              "id": "wf41-setsel-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "41cc614d-6b46-4191-bffe-499e53c00f94",
      "name": "Set — Select Embedding Model",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2864,
        560
      ],
      "notes": "PURPOSE: Resolve embedding_model_id from payload override or default model lookup and write back into req.job.payload.embedding_model_id. INPUT: payload and/or default model row. OUTPUT: embedding_model_id + normalized req/ctx/job. WHY: both chunk_document enqueue and embed_chunks path require deterministic resolved model id."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "embedding_models",
          "mode": "list",
          "cachedResultName": "embedding_models"
        },
        "limit": 1,
        "where": {
          "values": [
            {
              "column": "is_active",
              "value": "={{ true }}"
            }
          ]
        },
        "sort": {
          "values": [
            {
              "column": "id"
            }
          ]
        },
        "options": {}
      },
      "id": "9aea5909-82b8-4143-93a1-12df8a3b54d5",
      "name": "DB — Select Default Embedding Model",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        2704,
        672
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Fetch deterministic default embedding model (first active by id). INPUT: req context. OUTPUT: model row or empty item (always output). WHY: payload embedding_model_id may be absent for both chunk_document enqueue and embed_chunks execution."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "af6ccdf8-f162-4e0c-a8c2-4f2c33ac9d34",
              "leftValue": "={{ $json.req.job.payload.embedding_model_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "a9225ce2-1e0b-43dc-b9b1-3b89a6b0e874",
      "name": "IF — Payload Has Embedding Model",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        2512,
        560
      ],
      "notes": "PURPOSE: Branch model resolution based on payload.embedding_model_id. INPUT: chunk state. OUTPUT TRUE: use payload model; FALSE: load default model. WHY: required enqueue model selection rule."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "1d1ebf7f-7f0d-4705-987b-4d14c833f952",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "e3ae3f0d-fcfe-472a-93db-f1ef03d4f712",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "ba1feef6-b0de-4021-94a6-41f86ffbd90d",
              "name": "data.document_id",
              "value": "={{ $('Set — Decide Rechunk').item.json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "801ae7e1-a9bc-4327-a5d9-b7d8c81a7e7d",
              "name": "data.chunk_count",
              "value": "={{ $items('DB — Upsert Chunk').length }}",
              "type": "number"
            },
            {
              "id": "6f7a353d-a414-43bc-abd8-9148e8d5f27c",
              "name": "data.embed_enqueued",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "f06c0c87-e36f-40de-a283-c823072078cf",
              "name": "data.embedding_model_id",
              "value": "={{ $('Set — Select Embedding Model').item.json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "fe4634d5-88fc-4de9-af49-0e7eb11f6978",
              "name": "error",
              "value": null,
              "type": "string"
            },
            {
              "id": "013ed014-e958-4020-90f2-1897de4af8ec",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "f61954f6-3b5a-4949-830d-a38d7d4d0f3a",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "0f7807fc-e3b8-4a73-9837-5e7c089670ff",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $('Set — Decide Rechunk').item.json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "0818f370-fafa-4f3d-8e88-62356e33d7f4",
              "name": "meta.correlation.trace_id",
              "value": "={{ $('Set — Decide Rechunk').item.json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "0051f5af-35f4-4b81-a53c-c423dd10f6ee",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $('Set — Decide Rechunk').item.json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "bb07f835-60a1-4ef5-a954-f4a211d4f20e",
              "name": "meta.correlation.chat_id",
              "value": "={{ $('Set — Decide Rechunk').item.json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "e2520a61-d97f-4f74-b2f5-8e5e13b53f08",
              "name": "meta.correlation.message_id",
              "value": "={{ $('Set — Decide Rechunk').item.json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "4f0e90b5-d0fd-4f11-9128-5239e66e9e6b",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "4f0719b8-6585-4051-a6c4-e88ee2c980d2",
              "name": "meta.correlation.node",
              "value": "DB — Enqueue embed_chunks Job",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "3b96760b-22ff-4374-b49b-2da1e7123d3b",
      "name": "OUT — Success Chunk",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3280,
        544
      ],
      "notes": "PURPOSE: Build SuccessEnvelope for chunk_document happy path. INPUT: enqueue result + resolved model + chunk stats. OUTPUT: contract envelope. WHY: required WF41 success contract."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "3dfe123b-2f49-489c-a30d-2f9189df533f",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "69c97c4c-fd82-4902-b74f-e19f36f443a6",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "d8e94bec-1178-4d28-8c63-4a4ae67cc7d4",
              "name": "data.document_id",
              "value": "={{ $json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "17155f31-77ec-4d46-ba44-8db6cc3d95f4",
              "name": "data.skipped",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "b3d50548-e00f-4a57-9ce7-0e6f314f44aa",
              "name": "data.reason",
              "value": "already_chunked",
              "type": "string"
            },
            {
              "id": "f19b5e8f-bbca-44d0-8cf5-bf09c95ba91a",
              "name": "error",
              "value": null,
              "type": "string"
            },
            {
              "id": "fd5fa842-444e-477d-a9f7-2f4924d7ed48",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "4d00a0c4-df96-4df8-93ff-c2f90c980d15",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "a1b47db6-a5dd-4a1f-8f78-f5a1f31fcc23",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "5ce4548c-2eb8-4ec3-8641-02441f114ef9",
              "name": "meta.correlation.trace_id",
              "value": "={{ $json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "a8908c97-587e-4837-9dc4-5953f9f6c76e",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "a18480c6-b8b5-4dcd-ba07-7954b10af03c",
              "name": "meta.correlation.chat_id",
              "value": "={{ $json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "dc2b7c0b-a9eb-4515-8625-11e7c18fba26",
              "name": "meta.correlation.message_id",
              "value": "={{ $json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "3b8868f5-d051-4239-be29-c2494ad9fddb",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "7418a010-27d0-4510-80b7-8d8544d3d2ec",
              "name": "meta.correlation.node",
              "value": "IF — Needs Rechunk",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "e24cd633-898a-46fd-a452-99da0e93587f",
      "name": "OUT — Success Already Chunked",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1776,
        928
      ],
      "notes": "PURPOSE: Return SuccessEnvelope when chunks are up-to-date and no rechunk needed. INPUT: idempotency false branch. OUTPUT: skipped already_chunked envelope. WHY: idempotent short-circuit."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "6e977b98-8e1f-4d8c-b95e-6ca3ecde4fc2",
              "name": "_err.node",
              "value": "GUARD — Preflight Input",
              "type": "string"
            },
            {
              "id": "af2967b2-3992-4efd-82c8-d73d51554263",
              "name": "_err.operation",
              "value": "validate_input",
              "type": "string"
            },
            {
              "id": "7fdb9665-6d8c-49a4-8e53-f98bb6e91d54",
              "name": "ctx",
              "value": "={{ $json.ctx }}",
              "type": "object"
            },
            {
              "id": "9f92cc41-caf3-4ee0-8f35-b56a1d66bf16",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "376b4879-36c7-4ad4-9ed2-d8d3f3a6c7bb",
      "name": "ERR — Source Input Guard",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3568,
        2880
      ],
      "notes": "PURPOSE: Mark validation source metadata for ErrorPipe. INPUT: guard false branch. OUTPUT: _err.* + ctx/req for WF99. WHY: managed validation error handling."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7e20f96d-658c-4b38-a6b7-79f4acdb5bca",
              "name": "error_context.kind",
              "value": "validation",
              "type": "string"
            },
            {
              "id": "28f2f579-f58b-49d3-865d-2383f0738f75",
              "name": "error_context.message",
              "value": "Missing req.ctx, req.job, or req.job.payload.document_id",
              "type": "string"
            },
            {
              "id": "533bb3f5-a8d0-4148-aed8-47ef3d35b4f6",
              "name": "error_context.status_code",
              "value": 400,
              "type": "number"
            },
            {
              "id": "c03a7606-8b89-4aa1-a812-e85d640260ce",
              "name": "error_context.retryable",
              "value": false,
              "type": "boolean"
            },
            {
              "id": "4f25d5ea-4400-447b-8d66-2d2862274978",
              "name": "error_context.details.node",
              "value": "={{ $json._err.node }}",
              "type": "string"
            },
            {
              "id": "f43411fc-0f58-4ad3-bbc8-4f8cbf9f85ad",
              "name": "error_context.details.operation",
              "value": "={{ $json._err.operation }}",
              "type": "string"
            },
            {
              "id": "6d17dfd4-e845-4811-af2d-5f84de0d76e4",
              "name": "error_context.ctx",
              "value": "={{ $json.ctx }}",
              "type": "object"
            },
            {
              "id": "949f8723-afca-4955-8f15-576845f5a5b2",
              "name": "ctx.contracts.errorpipe",
              "value": 1,
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "fec8c0a5-5cde-45b4-9a0e-1269cc24f1cc",
      "name": "ERR — Prepare ErrorPipe v1 (Input)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3840,
        2880
      ],
      "notes": "PURPOSE: Build ErrorPipe v1 payload for validation failures. INPUT: err source item. OUTPUT: error_context.* for WF99. WHY: WF41 must delegate envelope creation to WF99."
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gcM1ZRVCKVtzJfHOH7OTw",
          "mode": "list",
          "cachedResultUrl": "/workflow/gcM1ZRVCKVtzJfHOH7OTw",
          "cachedResultName": "WF99 — Global ERR Handler"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "320a6076-cd01-4ff2-8503-4ccedcceb4e1",
      "name": "Execute WF99 (Input)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        4080,
        2880
      ],
      "notes": "PURPOSE: Delegate managed validation errors to WF99 and return its ErrorEnvelope. INPUT: error_context. OUTPUT: WF99 envelope. WHY: centralized error pipeline."
    },
    {
      "parameters": {},
      "id": "39af5df1-ad76-479e-b220-8b4b7ebfb5e1",
      "name": "Merge — Final (Success + WF99)",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        6400,
        1232
      ],
      "notes": "PURPOSE: Merge terminal success and WF99 error envelopes into workflow output stream. INPUTS: success envelopes (input 0) and WF99 envelopes (input 1). OUTPUT: final contract envelope item(s). WHY: single workflow exit path without StopAndError."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "wf41-guard-model-id",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "wf41-guard-model-dim",
              "leftValue": "={{ Number($json.output_dim || 0) }}",
              "rightValue": 1536,
              "operator": {
                "type": "number",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "dc6a3d97-38a5-45d3-ad6c-cbe490eac0c7",
      "name": "GUARD — Embed Has Model ID",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -320,
        1152
      ],
      "notes": "PURPOSE: Validate embedding model row exists and output_dim matches required 1536 for destination pgvector table. INPUT: merged model row + req context. OUTPUT TRUE: proceed to chunk embedding; FALSE: managed validation error to WF99. WHY: prevent invalid model or dimension mismatch writes."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "embedding_models",
          "mode": "list",
          "cachedResultName": "embedding_models"
        },
        "limit": 1,
        "where": {
          "values": [
            {
              "column": "id",
              "value": "={{ $json.embedding_model_id || $json.req?.job?.payload?.embedding_model_id }}"
            },
            {
              "column": "is_active",
              "value": "={{ true }}"
            }
          ]
        },
        "options": {}
      },
      "id": "a5b8894f-ae58-4907-af36-0178a1df9bc8",
      "name": "DB — Select Embedding Model",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        0,
        1504
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Load active embedding model by resolved embedding_model_id. INPUT: resolved model id + req context. OUTPUT: embedding model row (or empty item). WHY: embed_chunks requires provider/model_key/output_dim validation before API calls."
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunks",
          "mode": "list",
          "cachedResultName": "chunks"
        },
        "where": {
          "values": [
            {
              "column": "document_id",
              "value": "={{ $json.req.job.payload.document_id }}"
            }
          ]
        },
        "options": {}
      },
      "id": "8b4b19fb-2920-45e9-8a2a-ec3c48a02834",
      "name": "DB — Select Chunks For Embed",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        176,
        1376
      ],
      "alwaysOutputData": true,
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Load chunks for embed_chunks processing. INPUT: document_id. OUTPUT: chunk rows (or empty item when none). WHY: embed path source set."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "d57b4e31-d3c0-4459-97cb-63bf876f13ef",
              "leftValue": "={{ $json.id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "5c36090b-50fd-4d58-a11f-db72a8cb53b5",
      "name": "GUARD — Has Chunks For Embed",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        400,
        1248
      ],
      "notes": "PURPOSE: Branch embed flow when chunk set is empty. INPUT: chunk query output. OUTPUT TRUE: embed path, FALSE: skipped no_chunks success. WHY: required edge behavior."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "df31b8e9-e488-4771-a73c-d2e3243b487f",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "95d2dcf2-9e77-4ad9-8b3f-a43e2d8ecf8f",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "0102a141-5bb5-4d5d-b79e-43f0ed9af773",
              "name": "data.document_id",
              "value": "={{ $json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "5b703f72-74cb-4cb1-84ec-17ed0bf98b1f",
              "name": "data.embedding_model_id",
              "value": "={{ $json.req.job.payload.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "5212f625-c0ea-45bb-b31f-c6b98a30dba0",
              "name": "data.skipped",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "d0f6dfad-e278-49f4-bb95-bef13d2a95db",
              "name": "data.reason",
              "value": "no_chunks",
              "type": "string"
            },
            {
              "id": "8360af28-cc57-486f-80cc-f06a39bf07ec",
              "name": "error",
              "value": null,
              "type": "string"
            },
            {
              "id": "f4832f8d-a832-437d-9534-0887485bc13f",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "5f8f714a-49e0-4b14-b733-9ec98a70f915",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "cfd3e3a9-1568-4cea-9e14-a7f763badf3a",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $json.req.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "7f09997b-cdf3-4f97-9142-ed622226f75d",
              "name": "meta.correlation.trace_id",
              "value": "={{ $json.req.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "d461b18a-fc8b-4cfd-8f1f-d70ecb7af758",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $json.req.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "333f539a-1250-4cd1-b242-7e1f23079857",
              "name": "meta.correlation.chat_id",
              "value": "={{ $json.req.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "79de8d93-0bd1-43c8-bbc9-2288166eb4d2",
              "name": "meta.correlation.message_id",
              "value": "={{ $json.req.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "ba9d80cc-ca58-42f5-ad3b-718e705fffdc",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "0738d7d0-2781-4b67-a6cb-f12c1a265ecb",
              "name": "meta.correlation.node",
              "value": "GUARD — Has Chunks For Embed",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "4babc11a-0942-44b1-9764-1bf477bfd145",
      "name": "OUT — Success No Chunks",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        800,
        1696
      ],
      "notes": "PURPOSE: Return SuccessEnvelope skipped=no_chunks for embed path. INPUT: no chunk branch. OUTPUT: contract envelope. WHY: required embed edge case."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "7f5ea860-f4f4-4fa5-a7e6-f4d91d73566b",
              "name": "ok",
              "value": true,
              "type": "boolean"
            },
            {
              "id": "47fb7fa2-bf4f-45e2-9fb9-876bf143935e",
              "name": "status_code",
              "value": 200,
              "type": "number"
            },
            {
              "id": "5cf67bde-0f44-42ca-8e6a-60151366cae7",
              "name": "data.document_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.req.job.payload.document_id }}",
              "type": "number"
            },
            {
              "id": "260f8c0a-67eb-4f90-b6db-04d5ac277f8a",
              "name": "data.embedding_model_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "38ad9a01-6a2d-4728-a6a2-ab51f4201d23",
              "name": "data.embedded_count",
              "value": "={{ $(\"DB — Upsert Embedding\").all().length }}",
              "type": "number"
            },
            {
              "id": "ba1ca6a4-a6be-40f2-8362-dc8c7ff13d33",
              "name": "error",
              "value": null,
              "type": "string"
            },
            {
              "id": "2dc2e7df-4ad7-470d-9232-3cf7736f1210",
              "name": "meta.source",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "ae818839-9ab9-4c85-96bc-41d2f7e88bce",
              "name": "meta.ts",
              "value": "={{ $now.toISO() }}",
              "type": "string"
            },
            {
              "id": "d8dcaec6-d99e-4598-aa28-f4f9f5f66034",
              "name": "meta.correlation.correlation_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.correlation_id }}",
              "type": "string"
            },
            {
              "id": "9af21071-fb2e-406a-b8be-edb6d6ad3e1d",
              "name": "meta.correlation.trace_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.trace_id || null }}",
              "type": "string"
            },
            {
              "id": "b5eb5e64-21ff-4ec2-8f60-bfbb7c66ac9a",
              "name": "meta.correlation.tenant_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.tenant_id || null }}",
              "type": "string"
            },
            {
              "id": "30b3af56-58cc-4833-9dc4-b13f8c4bc6f8",
              "name": "meta.correlation.chat_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.chat_id || null }}",
              "type": "number"
            },
            {
              "id": "82439f34-a1a7-4fd7-af93-8c2f5e416111",
              "name": "meta.correlation.message_id",
              "value": "={{ $(\"Set — Embed Batch Config\").first().json.ctx.message_id || null }}",
              "type": "number"
            },
            {
              "id": "216408b9-5058-4f7d-b780-c3d38ab0f739",
              "name": "meta.correlation.workflow",
              "value": "WF41",
              "type": "string"
            },
            {
              "id": "d8e66531-f28a-4d08-a258-0c4d85239c2d",
              "name": "meta.correlation.node",
              "value": "OUT — Success Embed",
              "type": "string"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "35bfeaed-4f24-47f2-b4c3-090240177822",
      "name": "OUT — Success Embed",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2624,
        2208
      ],
      "notes": "PURPOSE: Return SuccessEnvelope for embed_chunks happy path with real stats after full batched upsert loop. INPUT: SplitInBatches done output + accumulated upsert history. OUTPUT: document_id, embedding_model_id, embedded_count, correlation meta. WHY: WF41 worker output contract."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "wf41-if-embed-route",
              "leftValue": "={{ $json.req?.job?.job_type }}",
              "rightValue": "embed_chunks",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "6e44cb08-d28d-421d-91bf-265dbdd95b85",
      "name": "IF — Embed Route After Model Resolve",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -160,
        656
      ],
      "notes": "PURPOSE: Split resolved embedding model flow by job_type. INPUT: Set — Select Embedding Model output. OUTPUT TRUE: embed_chunks path; FALSE: chunk_document enqueue path. WHY: shared model resolution node is reused by both branches."
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3
          },
          "combinator": "and",
          "conditions": [
            {
              "id": "wf41-guard-chunk-model",
              "leftValue": "={{ $json.embedding_model_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ]
        },
        "options": {}
      },
      "id": "114e467d-ac64-40fe-bdce-00ff497fffd3",
      "name": "GUARD — Chunk Has Model ID",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        80,
        448
      ],
      "notes": "PURPOSE: Ensure chunk_document enqueue has resolved embedding_model_id. INPUT: resolved model selection output. OUTPUT TRUE: enqueue embed job; FALSE: managed validation error. WHY: prevents enqueue payload with null model id."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "5cb6e83d-bbdb-4cac-ab1c-f953381c2e8a",
      "name": "Merge — Restore CTX after DB Embed Model",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        320,
        1152
      ],
      "notes": "PURPOSE: Carry/restore req/ctx/job after DB model lookup. INPUT1: DB model row. INPUT2: pre-DB context. OUTPUT: combined model + context. WHY: Postgres select overwrites item fields."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "b5eef8e7-ef81-41ea-8f14-89a64bda0587",
      "name": "Merge — Restore CTX after DB Embed Chunks",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        784,
        1376
      ],
      "notes": "PURPOSE: Carry/restore req/ctx/job/model after DB chunks lookup. INPUT1: chunk rows. INPUT2: validated model context. OUTPUT: chunk row + req/model context. WHY: Postgres select overwrites context needed downstream."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-bcfg-size",
              "name": "batch_size",
              "value": 50,
              "type": "number"
            },
            {
              "id": "wf41-bcfg-dim",
              "name": "expected_dim",
              "value": "={{ Number($json.output_dim || 1536) }}",
              "type": "number"
            },
            {
              "id": "wf41-bcfg-model",
              "name": "openai_model",
              "value": "={{ $json.model_key }}",
              "type": "string"
            },
            {
              "id": "wf41-bcfg-embed-id",
              "name": "embedding_model_id",
              "value": "={{ $json.id || $json.embedding_model_id || $json.req?.job?.payload?.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "wf41-bcfg-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            },
            {
              "id": "wf41-bcfg-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "wf41-bcfg-job",
              "name": "job",
              "value": "={{ $json.job || $json.req?.job || {} }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "4a6e6e48-74a5-4091-91c8-b7ad5771b62d",
      "name": "Set — Embed Batch Config",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1024,
        1200
      ],
      "notes": "PURPOSE: Configure embedding batch parameters and keep req context on each chunk item. INPUT: chunk row + model context. OUTPUT: batch_size, expected_dim, openai_model, embedding_model_id + context. WHY: consistent batch API calls and dimension validation."
    },
    {
      "parameters": {
        "batchSize": "={{ $json.batch_size || 50 }}",
        "options": {
          "reset": false
        }
      },
      "id": "ecb07c6b-6844-4317-933e-16c4e826798c",
      "name": "Split — Embed Batches",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        1200,
        2096
      ],
      "notes": "PURPOSE: Iterate chunks in fixed-size groups for batched embeddings API calls. INPUT: chunk items with batch config. OUTPUT0: current batch; OUTPUT1: loop complete. WHY: required batched processing."
    },
    {
      "parameters": {
        "fieldsToAggregate": {
          "fieldToAggregate": [
            {
              "fieldToAggregate": "id"
            },
            {
              "fieldToAggregate": "text"
            },
            {
              "fieldToAggregate": "req"
            },
            {
              "fieldToAggregate": "ctx"
            },
            {
              "fieldToAggregate": "job"
            },
            {
              "fieldToAggregate": "embedding_model_id"
            },
            {
              "fieldToAggregate": "openai_model"
            },
            {
              "fieldToAggregate": "expected_dim"
            }
          ]
        },
        "options": {}
      },
      "id": "c8c2b7ea-6d6a-4ce9-bdca-6f080811c9a1",
      "name": "Aggregate — Embed Batch Inputs",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        1424,
        1808
      ],
      "notes": "PURPOSE: Collapse current SplitInBatches window into one item with arrays for chunk ids/texts. INPUT: one batch of chunk items. OUTPUT: aggregated arrays + carried context/model fields. WHY: OpenAI embeddings endpoint accepts array input."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-openai-ids",
              "name": "batch_chunk_ids",
              "value": "={{ Array.isArray($json.id) ? $json.id : [$json.id] }}",
              "type": "array"
            },
            {
              "id": "wf41-openai-texts",
              "name": "batch_texts",
              "value": "={{ (Array.isArray($json.text) ? $json.text : [$json.text]).map(v => String(v ?? \"\")) }}",
              "type": "array"
            },
            {
              "id": "wf41-openai-req",
              "name": "req",
              "value": "={{ Array.isArray($json.req) ? ($json.req[0] || {}) : ($json.req || {}) }}",
              "type": "object"
            },
            {
              "id": "wf41-openai-ctx",
              "name": "ctx",
              "value": "={{ Array.isArray($json.ctx) ? ($json.ctx[0] || {}) : ($json.ctx || {}) }}",
              "type": "object"
            },
            {
              "id": "wf41-openai-job",
              "name": "job",
              "value": "={{ Array.isArray($json.job) ? ($json.job[0] || {}) : ($json.job || {}) }}",
              "type": "object"
            },
            {
              "id": "wf41-openai-model",
              "name": "openai_model",
              "value": "={{ Array.isArray($json.openai_model) ? ($json.openai_model[0] || \"\") : ($json.openai_model || \"\") }}",
              "type": "string"
            },
            {
              "id": "wf41-openai-embedid",
              "name": "embedding_model_id",
              "value": "={{ Array.isArray($json.embedding_model_id) ? ($json.embedding_model_id[0] || null) : $json.embedding_model_id }}",
              "type": "number"
            },
            {
              "id": "wf41-openai-dim",
              "name": "expected_dim",
              "value": "={{ Number(Array.isArray($json.expected_dim) ? ($json.expected_dim[0] || 1536) : ($json.expected_dim || 1536)) }}",
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "d45d3138-d1a3-4299-97bc-7c52f243821e",
      "name": "Set — Prepare OpenAI Batch Request",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1664,
        1888
      ],
      "notes": "PURPOSE: Prepare single-item OpenAI embeddings request payload for current batch. INPUT: aggregated batch arrays. OUTPUT: batch_chunk_ids, batch_texts, openai_model, expected_dim, embedding_model_id, req/ctx/job. WHY: clean request contract for HTTP node and carry/restore."
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/embeddings",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: $json.openai_model, input: $json.batch_texts }) }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "json"
            }
          },
          "timeout": 120000
        }
      },
      "id": "ca24e340-44ce-43e0-ab4b-f9d86c3e7d6d",
      "name": "HTTP — OpenAI Embeddings",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1904,
        1744
      ],
      "credentials": {
        "openAiApi": {
          "id": "LB6ntiMR8lDYKSy4",
          "name": "OpenAi account"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Call OpenAI batched embeddings API with array input. INPUT: openai_model + batch_texts. OUTPUT: JSON response with data[].embedding vectors. WHY: embed_chunks must generate vectors in batches."
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineAll",
        "options": {}
      },
      "id": "96767c1a-fae7-46ac-bcc6-8fcfafd95e15",
      "name": "Merge — Restore CTX after HTTP Embeddings",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2304,
        1984
      ],
      "notes": "PURPOSE: Restore batch context after HTTP call. INPUT1: OpenAI response. INPUT2: prepared batch payload. OUTPUT: response + batch ids/texts/model/context. WHY: HTTP node output does not preserve full context."
    },
    {
      "parameters": {
        "jsCode": "const data = $json.data;\nconst ids = Array.isArray($json.batch_chunk_ids) ? $json.batch_chunk_ids : [];\nconst expectedDim = Number($json.expected_dim || 1536);\nif (!Array.isArray(data)) throw new Error('OpenAI embeddings response.data is not an array');\nif (data.length !== ids.length) throw new Error('OpenAI embeddings length mismatch with batch_chunk_ids');\nconst out = [];\nfor (let i = 0; i < ids.length; i++) {\n  const vec = data[i]?.embedding;\n  if (!Array.isArray(vec)) throw new Error('Embedding vector missing at index ' + i);\n  if (vec.length !== expectedDim) throw new Error('Embedding dimension mismatch at index ' + i + ': ' + vec.length + ' != ' + expectedDim);\n  out.push({\n    json: {\n      req: $json.req,\n      ctx: $json.ctx,\n      job: $json.job,\n      chunk_id: ids[i],\n      embedding_model_id: $json.embedding_model_id,\n      embedding_vec: vec,\n      embedding_len: vec.length,\n      expected_dim: expectedDim\n    }\n  });\n}\nreturn out;"
      },
      "id": "68ba2a77-c589-4c5b-ab41-ce73e2383e58",
      "name": "CODE — Expand Embeddings Batch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2704,
        1696
      ],
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Validate OpenAI response lengths/dimensions and fan out to one item per chunk. INPUT: batch ids + response.data embeddings + expected_dim. OUTPUT: one item per chunk with embedding_vec and context. WHY: deterministic mapping response index -> chunk_id."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-vec-str",
              "name": "embedding_str",
              "value": "={{ \"[\" + $json.embedding_vec.join(\",\") + \"]\" }}",
              "type": "string"
            },
            {
              "id": "wf41-vec-req",
              "name": "req",
              "value": "={{ $json.req }}",
              "type": "object"
            },
            {
              "id": "wf41-vec-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx }}",
              "type": "object"
            },
            {
              "id": "wf41-vec-job",
              "name": "job",
              "value": "={{ $json.job }}",
              "type": "object"
            },
            {
              "id": "wf41-vec-chunk",
              "name": "chunk_id",
              "value": "={{ $json.chunk_id }}",
              "type": "number"
            },
            {
              "id": "wf41-vec-mid",
              "name": "embedding_model_id",
              "value": "={{ $json.embedding_model_id }}",
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "7749f4b6-7986-430a-85aa-e21d426a9204",
      "name": "Set — Prepare Embedding Vector",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3072,
        1248
      ],
      "notes": "PURPOSE: Convert numeric vector array to pgvector string literal format for Postgres upsert. INPUT: embedding_vec per chunk. OUTPUT: embedding_str + chunk/model/context fields. WHY: pgvector column accepts string vector representation."
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "value": "kg",
          "mode": "list",
          "cachedResultName": "kg"
        },
        "table": {
          "__rl": true,
          "value": "chunk_embeddings_1536",
          "mode": "list",
          "cachedResultName": "chunk_embeddings_1536"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "chunk_id": "={{ $json.chunk_id }}",
            "model_id": "={{ $json.embedding_model_id }}",
            "embedding": "={{ $json.embedding_str }}"
          },
          "matchingColumns": [
            "chunk_id",
            "model_id"
          ],
          "schema": [
            {
              "id": "chunk_id",
              "displayName": "chunk_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "model_id",
              "displayName": "model_id",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "canBeUsedToMatch": true
            },
            {
              "id": "embedding",
              "displayName": "embedding",
              "required": true,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            }
          ]
        },
        "options": {}
      },
      "id": "be998edf-1d37-403b-a94b-4aaf27ec8da8",
      "name": "DB — Upsert Embedding",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        3280,
        1248
      ],
      "credentials": {
        "postgres": {
          "id": "yckAFBLpmdhsPaDZ",
          "name": "Postgres DF Assistant"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "PURPOSE: Upsert chunk embedding vector into kg.chunk_embeddings_1536 using PK (chunk_id, model_id). INPUT: chunk_id + embedding_model_id + embedding_str. OUTPUT: upsert result rows. WHY: idempotent persistence for embed_chunks."
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "options": {}
      },
      "id": "2854b6ed-f26e-47d3-a1f2-253564b6860b",
      "name": "Aggregate — Batch Upsert Results",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        3968,
        1216
      ],
      "notes": "PURPOSE: Collapse per-chunk upsert outputs to one item to continue SplitInBatches loop once per batch. INPUT: N upsert rows for current batch. OUTPUT: single aggregate item. WHY: prevent loop control fan-out."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Default Embed Model-node",
              "name": "_err.node",
              "value": "DB — Select Default Embedding Model",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Default Embed Model-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Default Embed Model-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Default Embed Model-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "13356d6f-5fdb-4d4a-b371-fb53ecbdbd67",
      "name": "ERR — Source DB Default Embed Model",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4512,
        2720
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Select Default Embedding Model failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Embed Model-node",
              "name": "_err.node",
              "value": "DB — Select Embedding Model",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Model-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Embed Model-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Embed Model-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "0a3664de-1516-432f-9ca1-6c01de278003",
      "name": "ERR — Source DB Embed Model",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        320,
        1600
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Select Embedding Model failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Embed Chunks-node",
              "name": "_err.node",
              "value": "DB — Select Chunks For Embed",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-op",
              "name": "_err.operation",
              "value": "select",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-table",
              "name": "_err.table",
              "value": "kg.chunks",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Embed Chunks-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Embed Chunks-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Embed Chunks-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "2ba806c6-4c55-4d27-928e-cb4fdb213f93",
      "name": "ERR — Source DB Embed Chunks",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        784,
        1600
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Select Chunks For Embed failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-node",
              "name": "_err.node",
              "value": "HTTP — OpenAI Embeddings",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-op",
              "name": "_err.operation",
              "value": "post",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-table",
              "name": "_err.table",
              "value": "openai.v1.embeddings",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source HTTP OpenAI Embeddings-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "79a970b1-364d-43c2-8c68-d2df853fd77a",
      "name": "ERR — Source HTTP OpenAI Embeddings",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2272,
        1712
      ],
      "notes": "PURPOSE: Mark source metadata for HTTP — OpenAI Embeddings failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source CODE Expand Embeddings-node",
              "name": "_err.node",
              "value": "CODE — Expand Embeddings Batch",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-op",
              "name": "_err.operation",
              "value": "validate_embeddings",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-table",
              "name": "_err.table",
              "value": "batch",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-kind",
              "name": "_err.kind",
              "value": "={{ 'validation' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"OpenAI embedding response validation failed\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-status",
              "name": "_err.status_code",
              "value": "={{ 422 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source CODE Expand Embeddings-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "510ba8b3-ca2a-46d3-b1dc-266d5ed719d1",
      "name": "ERR — Source CODE Expand Embeddings",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3152,
        1616
      ],
      "notes": "PURPOSE: Mark source metadata for CODE — Expand Embeddings Batch failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source DB Upsert Embedding-node",
              "name": "_err.node",
              "value": "DB — Upsert Embedding",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-op",
              "name": "_err.operation",
              "value": "upsert",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-table",
              "name": "_err.table",
              "value": "kg.chunk_embeddings_1536",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-kind",
              "name": "_err.kind",
              "value": "={{ 'io' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-msg",
              "name": "_err.message",
              "value": "={{ $json.error?.message || \"WF41 embed failure\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-status",
              "name": "_err.status_code",
              "value": "={{ 500 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source DB Upsert Embedding-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "547ea4e6-ae33-4eaf-9e1f-c3d27f3e9bbb",
      "name": "ERR — Source DB Upsert Embedding",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4272,
        2272
      ],
      "notes": "PURPOSE: Mark source metadata for DB — Upsert Embedding failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source Embed Model Guard-node",
              "name": "_err.node",
              "value": "GUARD — Embed Has Model ID",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-op",
              "name": "_err.operation",
              "value": "validate_model",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-kind",
              "name": "_err.kind",
              "value": "={{ 'validation' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-msg",
              "name": "_err.message",
              "value": "={{ $json.id ? (\"Embedding dimension mismatch: expected 1536 got \" + $json.output_dim) : \"Embedding model not found or inactive\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Embed Model Guard-status",
              "name": "_err.status_code",
              "value": "={{ $json.id ? 422 : 404 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source Embed Model Guard-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source Embed Model Guard-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "d64b6536-93b4-4733-80b0-01d28f7894a9",
      "name": "ERR — Source Embed Model Guard",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        560,
        1600
      ],
      "notes": "PURPOSE: Mark source metadata for GUARD — Embed Has Model ID failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ERR — Source Chunk Model Guard-node",
              "name": "_err.node",
              "value": "GUARD — Chunk Has Model ID",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-op",
              "name": "_err.operation",
              "value": "validate_model",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-table",
              "name": "_err.table",
              "value": "kg.embedding_models",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-kind",
              "name": "_err.kind",
              "value": "={{ 'validation' }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-msg",
              "name": "_err.message",
              "value": "={{ \"No active embedding model resolved for chunk_document enqueue\" }}",
              "type": "string"
            },
            {
              "id": "ERR — Source Chunk Model Guard-status",
              "name": "_err.status_code",
              "value": "={{ 422 }}",
              "type": "number"
            },
            {
              "id": "ERR — Source Chunk Model Guard-ctx",
              "name": "ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "ERR — Source Chunk Model Guard-req",
              "name": "req",
              "value": "={{ $json.req || { ctx: ($json.ctx||{}), job: ($json.job||{}) } }}",
              "type": "object"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {
          "dotNotation": true
        }
      },
      "id": "faccb2c5-0dcc-4272-84c8-0942a0bf2a18",
      "name": "ERR — Source Chunk Model Guard",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        320,
        240
      ],
      "notes": "PURPOSE: Mark source metadata for GUARD — Chunk Has Model ID failure and preserve req/ctx for WF99 ErrorPipe. INPUT: node error/guard-false item. OUTPUT: _err.* + req/ctx payload. WHY: per-node error attribution for embed path."
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "wf41-ep-kind",
              "name": "error_context.kind",
              "value": "={{ $json._err?.kind || ($json._err?.operation?.startsWith(\"validate\") ? \"validation\" : \"io\") }}",
              "type": "string"
            },
            {
              "id": "wf41-ep-msg",
              "name": "error_context.message",
              "value": "={{ $json._err?.message || $json.error?.message || \"WF41 embed path failure\" }}",
              "type": "string"
            },
            {
              "id": "wf41-ep-status",
              "name": "error_context.status_code",
              "value": "={{ Number($json._err?.status_code || ($json._err?.operation?.startsWith(\"validate\") ? 422 : 500)) }}",
              "type": "number"
            },
            {
              "id": "wf41-ep-retry",
              "name": "error_context.retryable",
              "value": "={{ !($json._err?.operation?.startsWith(\"validate\")) }}",
              "type": "boolean"
            },
            {
              "id": "wf41-ep-node",
              "name": "error_context.details.node",
              "value": "={{ $json._err?.node }}",
              "type": "string"
            },
            {
              "id": "wf41-ep-op",
              "name": "error_context.details.operation",
              "value": "={{ $json._err?.operation }}",
              "type": "string"
            },
            {
              "id": "wf41-ep-table",
              "name": "error_context.details.table",
              "value": "={{ $json._err?.table || null }}",
              "type": "string"
            },
            {
              "id": "wf41-ep-ctx",
              "name": "error_context.ctx",
              "value": "={{ $json.ctx || $json.req?.ctx || {} }}",
              "type": "object"
            },
            {
              "id": "wf41-ep-contract",
              "name": "ctx.contracts.errorpipe",
              "value": 1,
              "type": "number"
            }
          ]
        },
        "options": {
          "dotNotation": true
        }
      },
      "id": "c3a4c848-ef51-4785-b00e-9892ab66df7a",
      "name": "ERR — Prepare ErrorPipe v1 (Embed)",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        4928,
        2640
      ],
      "notes": "PURPOSE: Build ErrorPipe v1 payload for embed-path I/O and validation failures. INPUT: ERR — Source* item with _err metadata. OUTPUT: error_context.* + ctx.contracts.errorpipe=1 for WF99. WHY: centralized error envelope creation via WF99."
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "gcM1ZRVCKVtzJfHOH7OTw",
          "mode": "list",
          "cachedResultUrl": "/workflow/gcM1ZRVCKVtzJfHOH7OTw",
          "cachedResultName": "WF99 — Global ERR Handler"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "id": "bfceb09e-f130-4012-8051-84d283c26943",
      "name": "Execute WF99 (Embed)",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        5168,
        2640
      ],
      "notes": "PURPOSE: Delegate embed-path errors to WF99 and return ErrorEnvelope. INPUT: ErrorPipe v1 payload. OUTPUT: WF99 ErrorEnvelope. WHY: project-wide centralized error handling."
    },
    {
      "parameters": {},
      "id": "9ef14e7f-5fcd-4d17-bdc5-b51ebc61f4ab",
      "name": "Merge — Model Resolve Branches",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        3296,
        224
      ],
      "notes": "PURPOSE: Join IF model-resolution branches via Merge (project branch-join rule). INPUT1: payload model path. INPUT2: default model lookup path. OUTPUT: single stream for Set — Select Embedding Model."
    }
  ],
  "pinData": {},
  "connections": {
    "IN — Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Merge — IN (WF90 + TEST)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TEST — Manual Trigger": {
      "main": [
        [
          {
            "node": "TEST — Build Requests",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TEST — Build Requests": {
      "main": [
        [
          {
            "node": "Merge — IN (WF90 + TEST)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge — IN (WF90 + TEST)": {
      "main": [
        [
          {
            "node": "Set — Normalize Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Normalize Input": {
      "main": [
        [
          {
            "node": "GUARD — Preflight Input",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge — Restore CTX after DB Document",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "GUARD — Preflight Input": {
      "main": [
        [
          {
            "node": "SWITCH — Route job_type",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SWITCH — Route job_type": {
      "main": [
        [
          {
            "node": "DB — Select Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "IF — Payload Has Embedding Model",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Document": {
      "main": [
        [
          {
            "node": "Merge — Restore CTX after DB Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Restore CTX after DB Document": {
      "main": [
        [
          {
            "node": "GUARD — Document Has Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Document Has Text": {
      "main": [
        [
          {
            "node": "Crypto — Hash Document Text",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success Empty Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Crypto — Hash Document Text": {
      "main": [
        [
          {
            "node": "DB — Probe Existing Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Probe Existing Chunks": {
      "main": [
        [
          {
            "node": "Set — Decide Rechunk",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Decide Rechunk": {
      "main": [
        [
          {
            "node": "IF — Needs Rechunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Needs Rechunk": {
      "main": [
        [
          {
            "node": "DB — Delete Old Chunks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success Already Chunked",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Delete Old Chunks": {
      "main": [
        [
          {
            "node": "CODE — Build Chunks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CODE — Build Chunks": {
      "main": [
        [
          {
            "node": "Crypto — Hash Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Crypto — Hash Chunk": {
      "main": [
        [
          {
            "node": "Set — Prepare Chunk Row",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Prepare Chunk Row": {
      "main": [
        [
          {
            "node": "DB — Upsert Chunk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Upsert Chunk": {
      "main": [
        [
          {
            "node": "IF — Payload Has Embedding Model",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Payload Has Embedding Model": {
      "main": [
        [
          {
            "node": "Merge — Model Resolve Branches",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "DB — Select Default Embedding Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Default Embedding Model": {
      "main": [
        [
          {
            "node": "Merge — Model Resolve Branches",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "ERR — Source DB Default Embed Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Select Embedding Model": {
      "main": [
        [
          {
            "node": "IF — Embed Route After Model Resolve",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Enqueue embed_chunks Job": {
      "main": [
        [
          {
            "node": "OUT — Success Chunk",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Input Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source Input Guard": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Prepare ErrorPipe v1 (Input)": {
      "main": [
        [
          {
            "node": "Execute WF99 (Input)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute WF99 (Input)": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "OUT — Success Empty Text": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Embed Has Model ID": {
      "main": [
        [
          {
            "node": "DB — Select Chunks For Embed",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge — Restore CTX after DB Embed Chunks",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "ERR — Source Embed Model Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Embedding Model": {
      "main": [
        [
          {
            "node": "Merge — Restore CTX after DB Embed Model",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Embed Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Select Chunks For Embed": {
      "main": [
        [
          {
            "node": "Merge — Restore CTX after DB Embed Chunks",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Embed Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Has Chunks For Embed": {
      "main": [
        [
          {
            "node": "Set — Embed Batch Config",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success No Chunks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF — Embed Route After Model Resolve": {
      "main": [
        [
          {
            "node": "DB — Select Embedding Model",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge — Restore CTX after DB Embed Model",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "GUARD — Chunk Has Model ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GUARD — Chunk Has Model ID": {
      "main": [
        [
          {
            "node": "DB — Enqueue embed_chunks Job",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source Chunk Model Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Restore CTX after DB Embed Model": {
      "main": [
        [
          {
            "node": "GUARD — Embed Has Model ID",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Restore CTX after DB Embed Chunks": {
      "main": [
        [
          {
            "node": "GUARD — Has Chunks For Embed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Embed Batch Config": {
      "main": [
        [
          {
            "node": "Split — Embed Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split — Embed Batches": {
      "main": [
        [
          {
            "node": "Aggregate — Embed Batch Inputs",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "OUT — Success Embed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate — Embed Batch Inputs": {
      "main": [
        [
          {
            "node": "Set — Prepare OpenAI Batch Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Prepare OpenAI Batch Request": {
      "main": [
        [
          {
            "node": "HTTP — OpenAI Embeddings",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge — Restore CTX after HTTP Embeddings",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "HTTP — OpenAI Embeddings": {
      "main": [
        [
          {
            "node": "Merge — Restore CTX after HTTP Embeddings",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source HTTP OpenAI Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Restore CTX after HTTP Embeddings": {
      "main": [
        [
          {
            "node": "CODE — Expand Embeddings Batch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CODE — Expand Embeddings Batch": {
      "main": [
        [
          {
            "node": "Set — Prepare Embedding Vector",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source CODE Expand Embeddings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set — Prepare Embedding Vector": {
      "main": [
        [
          {
            "node": "DB — Upsert Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DB — Upsert Embedding": {
      "main": [
        [
          {
            "node": "Aggregate — Batch Upsert Results",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "ERR — Source DB Upsert Embedding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Default Embed Model": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Embed Model": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Embed Chunks": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source HTTP OpenAI Embeddings": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source CODE Expand Embeddings": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source DB Upsert Embedding": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source Embed Model Guard": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Source Chunk Model Guard": {
      "main": [
        [
          {
            "node": "ERR — Prepare ErrorPipe v1 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ERR — Prepare ErrorPipe v1 (Embed)": {
      "main": [
        [
          {
            "node": "Execute WF99 (Embed)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute WF99 (Embed)": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "OUT — Success Chunk": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OUT — Success Already Chunked": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OUT — Success No Chunks": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OUT — Success Embed": {
      "main": [
        [
          {
            "node": "Merge — Final (Success + WF99)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge — Model Resolve Branches": {
      "main": [
        [
          {
            "node": "Set — Select Embedding Model",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "5463b9cd-6c00-4fc3-9e42-0537f8361537",
  "meta": {
    "instanceId": "49b1b765c7a60d5365a95e5c3e2d1b2e695b21e61861bbe488c27ec04546a71d"
  },
  "id": "mRsYUkeg_hP-L6kzvpjis",
  "tags": []
}