# Telegram Knowledge Bot — Жёсткие правила разработки n8n workflow (v2)

Эти правила обязательны для всех промптов генерации workflow и для всей реализации проекта.

**Источник истины проекта:**

- **DB схема:** `SQL.txt`
- **Credentials / версии нод:** `Credentials.json`
- **Справочник по нодам n8n:** MCP connection `n8n-mcp`

---

## 1) Безопасность и секреты

1. **Secrets НЕ хранить в БД.** Всё — только в **n8n Credentials**.
2. Исключения (если и появятся) фиксируются отдельным решением и документируются.
3. **\$env.\***** в workflow запрещён** (в любых выражениях и полях).

---

## 2) Nocode-first

1. **Минимум Code node.** Логика — через стандартные ноды (Set/IF/Switch/Merge/Date&Time/Crypto/Postgres/HTTP/Telegram).
2. Если Code node неизбежен (редко):
   - коротко, детерминированно,
   - без сетевых вызовов,
   - с комментариями,
   - с объяснением WHY в Notes.
3. Для отдельных workflow может действовать более жёсткое правило: **Code node = 0**.

---

## 3) Notes у каждой ноды

Для **каждой** ноды обязательны Notes:

- что делает нода,
- какой вход ожидает и какой выход формирует,
- WHY — если включён нестандартный флаг/опция.

---

## 4) Контракт → тесты → реализация

1. Сначала фиксируется **контракт входа/выхода** (см. canvas: «Контракты входа/выхода workflow»).
2. Затем делаются тесты (минимум 3):
   - happy,
   - edge,
   - fail.
3. Потом реализация.

### Тесты должны быть “по-настоящему”

- **Тесты обязаны писать в БД** и проверять результаты через SELECT.
- **Тесты обязаны делать cleanup** (DELETE своих записей), чтобы не захламлять прод-таблицы.
- Ассерты не должны искать «последнюю запись по времени» — только по ключам теста (например, `correlation_id`, `job_id`).

### Запрет mock-веток

- Запрещены ветки, которые **подменяют prod-path** данных.
- Тестовая ветка может формировать тестовый вход, но дальше должна прогонять **тот же core pipeline**, что и прод.

---

## 5) Postgres node policy: никаких SQL-«хаков»

### Разрешённые операции

- По умолчанию разрешены только: **select / insert / update / upsert / delete**.
- **Execute Query / произвольный SQL запрещён**, если задачу можно решить стандартными операциями.

### Запреты

- Запрещены любые SQL-строки с динамической подстановкой/конкатенацией.

### Always Output Data

- По умолчанию **OFF**.
- **ON** допустим только для optional lookup, где отсутствие строки ожидаемо, и дальше стоит явная обработка пустого результата (Guard + Default через Set/Merge).
- Для required lookup: **AOD=OFF**, 0 rows → бизнес-ошибка (404/403), а не «пустой item».

### Паттерн “гарантировать 1 item”

Если select может вернуть 0 строк, а дальше нужен item:

- `SET — Default item` → `MERGE — merge with select result`.

---

## 6) STRICT обработка ошибок I/O (Postgres/HTTP/Telegram)

Цель: любая I/O ошибка даёт управляемый ErrorEnvelope и не ведёт к «частичным успехам».

### PATTERN A (по умолчанию)

1. На I/O ноде включить **Continue using error output**.
2. Сразу после — `IF — has_error` (проверяет наличие `errorMessage/errorDescription/n8nDetails` и т.п.).
3. TRUE → Build ErrorEnvelope → **StopAndError**.
4. FALSE → normal path.

### Retry On Fail

- Включать только на I/O нодах и только если есть понятная стратегия (кол-во попыток/задержка) и WHY в Notes.

### Минимальная классификация

- `kind`: `db | upstream | auth | rate_limit | unknown`
- `retryable=true` только для временных проблем (timeout/connection reset/deadlock/serialization/temporary unavailable/429).

---

## 7) Merge node policy (Hard Rule)

### Инвариант

В n8n JSON у ноды **Merge** количество входов **не выводится автоматически** из связей.

Если у Merge больше 2 входов, **обязательно** явно выставлять:

```json
"parameters": {
  "numberInputs": 3
}
```

где `3` — фактическое число входящих соединений.

### Запрещено

- Оставлять `numberInputs` по умолчанию (=2), если входов 3+.
- Подключать 3+ входящих связей к Merge без увеличения `numberInputs`.

### Обязательная самопроверка перед финальным JSON

Для каждой ноды типа `n8n-nodes-base.merge`:

1. Посчитать количество входящих соединений (in-degree).
2. Проверить, что `parameters.numberInputs` существует и равен этому числу.
3. Если не совпадает — исправить и только потом финализировать JSON.

### Notes для Merge

- Зачем Merge.
- Сколько входов ожидается (N).
- Что приходит на каждый вход.

### Требование для промптов генерации workflow

В каждый промпт генерации workflow ОБЯЗАТЕЛЬНО включать правило:
- «Если в workflow есть Merge с 3+ входами — выставь `parameters.numberInputs = N`, где N = число входящих связей. Иначе JSON считается неверным и должен быть исправлен до выдачи.»

Также в промпте обязателен пункт **IMPORT SAFETY CHECK**:
- перед финальным выводом JSON выполнить самопроверку: ни одна Merge-нода не имеет больше входящих связей, чем указано в `numberInputs`.

---

## 8) Quality gates для генерации JSON

Перед выдачей workflow JSON обязательно проверить:

1. Все credentials names строго из `Credentials.json`.
2. Нет `$env.*`.
3. Каждая I/O нода (Postgres/HTTP/Telegram) имеет error-output handling (Pattern A).
4. Merge ноды: `numberInputs` соответствует входящим связям.
5. Нет Execute Query (если это не отдельное явно разрешённое исключение, зафиксированное решением).
6. Есть тестовая ветка (Manual Trigger) с записью в БД + verify + cleanup.

---

## 9) Связанные документы

- Контракты I/O между workflow: **«Telegram Knowledge Bot — Контракты входа/выхода workflow»**

> Примечание: отдельный документ **«Telegram Knowledge Bot — Merge Node Policy (Hard Rule)»** считается полностью объединённым в этот регламент и больше не является источником истины.

