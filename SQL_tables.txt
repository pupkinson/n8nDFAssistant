-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS audit.qa_citations
(
    turn_id bigint NOT NULL,
    chunk_id bigint NOT NULL,
    rank integer NOT NULL,
    score double precision,
    snippet text COLLATE pg_catalog."default",
    source_ref jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT qa_citations_pkey PRIMARY KEY (turn_id, rank)
);

CREATE TABLE IF NOT EXISTS audit.qa_sessions
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL,
    tg_user_id bigint NOT NULL,
    channel audit.qa_channel NOT NULL,
    chat_id bigint,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    last_at timestamp with time zone NOT NULL DEFAULT now(),
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT qa_sessions_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS audit.qa_turns
(
    id bigserial NOT NULL,
    session_id uuid NOT NULL,
    question_text text COLLATE pg_catalog."default" NOT NULL,
    question_msg_version_id bigint,
    answer_text text COLLATE pg_catalog."default",
    answer_json jsonb,
    model_used text COLLATE pg_catalog."default",
    latency_ms integer,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT qa_turns_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS content.blob_objects
(
    id bigserial NOT NULL,
    sha256 bytea NOT NULL,
    byte_size bigint NOT NULL,
    storage_kind text COLLATE pg_catalog."default" NOT NULL,
    storage_key text COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT blob_objects_pkey PRIMARY KEY (id),
    CONSTRAINT blob_objects_sha256_key UNIQUE (sha256)
);

CREATE TABLE IF NOT EXISTS content.documents
(
    id bigserial NOT NULL,
    tenant_id uuid NOT NULL,
    doc_type content.doc_type NOT NULL,
    visibility core.visibility_scope NOT NULL DEFAULT 'group'::core.visibility_scope,
    dm_owner_user_id bigint,
    chat_id bigint,
    message_version_id bigint,
    file_unique_id text COLLATE pg_catalog."default",
    url_id bigint,
    source_created_at timestamp with time zone,
    title text COLLATE pg_catalog."default",
    language text COLLATE pg_catalog."default",
    text text COLLATE pg_catalog."default",
    text_sha256 bytea,
    token_count integer,
    status content.extract_status NOT NULL DEFAULT 'pending'::content.extract_status,
    error jsonb,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    description text COLLATE pg_catalog."default",
    CONSTRAINT documents_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS content.url_fetches
(
    id bigserial NOT NULL,
    url_id bigint NOT NULL,
    fetched_at timestamp with time zone NOT NULL DEFAULT now(),
    status content.fetch_status NOT NULL,
    http_status integer,
    content_type text COLLATE pg_catalog."default",
    etag text COLLATE pg_catalog."default",
    last_modified text COLLATE pg_catalog."default",
    body_sha256 bytea,
    storage_url text COLLATE pg_catalog."default",
    error jsonb,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT url_fetches_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS content.urls
(
    id bigserial NOT NULL,
    normalized_url text COLLATE pg_catalog."default" NOT NULL,
    canonical_url text COLLATE pg_catalog."default",
    first_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    last_seen_at timestamp with time zone,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT urls_pkey PRIMARY KEY (id),
    CONSTRAINT urls_normalized_url_key UNIQUE (normalized_url)
);

CREATE TABLE IF NOT EXISTS core.bot_transport_config
(
    bot_id uuid NOT NULL,
    desired_mode text COLLATE pg_catalog."default" NOT NULL DEFAULT 'webhook'::text,
    webhook_url text COLLATE pg_catalog."default",
    webhook_path text COLLATE pg_catalog."default",
    max_connections integer,
    allowed_updates jsonb NOT NULL DEFAULT '[]'::jsonb,
    drop_pending_updates boolean NOT NULL DEFAULT false,
    polling_timeout_sec integer NOT NULL DEFAULT 25,
    polling_limit integer NOT NULL DEFAULT 100,
    watchdog_interval_sec integer NOT NULL DEFAULT 60,
    unhealthy_pending_threshold integer NOT NULL DEFAULT 50,
    unhealthy_silence_sec integer NOT NULL DEFAULT 180,
    recovery_stable_sec integer NOT NULL DEFAULT 600,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT bot_transport_config_pkey PRIMARY KEY (bot_id)
);

CREATE TABLE IF NOT EXISTS core.bot_transport_state
(
    bot_id uuid NOT NULL,
    mode text COLLATE pg_catalog."default" NOT NULL DEFAULT 'webhook'::text,
    last_update_id bigint NOT NULL DEFAULT 0,
    last_webhook_seen_at timestamp with time zone,
    last_poll_seen_at timestamp with time zone,
    last_failover_at timestamp with time zone,
    last_recovery_at timestamp with time zone,
    last_switch_reason text COLLATE pg_catalog."default",
    hold_until timestamp with time zone,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT bot_transport_state_pkey PRIMARY KEY (bot_id)
);

CREATE TABLE IF NOT EXISTS core.bots
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    tenant_id uuid NOT NULL,
    tg_bot_user_id bigint,
    username citext COLLATE pg_catalog."default",
    webhook_path text COLLATE pg_catalog."default",
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    is_active boolean NOT NULL DEFAULT true,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT bots_pkey PRIMARY KEY (id),
    CONSTRAINT bots_tenant_id_username_key UNIQUE (tenant_id, username)
);

CREATE TABLE IF NOT EXISTS core.chat_policies
(
    tenant_id uuid NOT NULL,
    chat_id bigint NOT NULL,
    retention_days_raw integer NOT NULL DEFAULT 90,
    retention_days_documents integer NOT NULL DEFAULT 3650,
    allow_url_fetch boolean NOT NULL DEFAULT true,
    allow_file_download boolean NOT NULL DEFAULT true,
    allow_embedding boolean NOT NULL DEFAULT true,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT chat_policies_pkey PRIMARY KEY (tenant_id, chat_id)
);

CREATE TABLE IF NOT EXISTS core.tenant_chats
(
    tenant_id uuid NOT NULL,
    chat_id bigint NOT NULL,
    chat_type core.chat_type NOT NULL,
    title text COLLATE pg_catalog."default",
    username citext COLLATE pg_catalog."default",
    is_enabled boolean NOT NULL DEFAULT true,
    added_by bigint,
    added_at timestamp with time zone NOT NULL DEFAULT now(),
    last_seen_at timestamp with time zone,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT tenant_chats_pkey PRIMARY KEY (tenant_id, chat_id)
);

CREATE TABLE IF NOT EXISTS core.tenant_users
(
    tenant_id uuid NOT NULL,
    tg_user_id bigint NOT NULL,
    role core.principal_role NOT NULL DEFAULT 'user'::core.principal_role,
    added_by bigint,
    added_at timestamp with time zone NOT NULL DEFAULT now(),
    note text COLLATE pg_catalog."default",
    CONSTRAINT tenant_users_pkey PRIMARY KEY (tenant_id, tg_user_id)
);

CREATE TABLE IF NOT EXISTS core.tenants
(
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    name text COLLATE pg_catalog."default" NOT NULL,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT tenants_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS kg.chunk_embeddings_1536
(
    chunk_id bigint NOT NULL,
    model_id smallint NOT NULL,
    embedding vector(1536) NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT chunk_embeddings_1536_pkey PRIMARY KEY (chunk_id, model_id)
);

CREATE TABLE IF NOT EXISTS kg.chunks
(
    id bigserial NOT NULL,
    document_id bigint NOT NULL,
    chunk_no integer NOT NULL,
    char_start integer,
    char_end integer,
    text text COLLATE pg_catalog."default" NOT NULL,
    tsv tsvector GENERATED ALWAYS AS (to_tsvector('simple'::regconfig, COALESCE(text, ''::text))) STORED,
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT chunks_pkey PRIMARY KEY (id),
    CONSTRAINT chunks_document_id_chunk_no_key UNIQUE (document_id, chunk_no)
);

CREATE TABLE IF NOT EXISTS kg.embedding_models
(
    id smallserial NOT NULL,
    provider text COLLATE pg_catalog."default" NOT NULL,
    model_key text COLLATE pg_catalog."default" NOT NULL,
    task_type text COLLATE pg_catalog."default",
    output_dim integer NOT NULL,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT embedding_models_pkey PRIMARY KEY (id),
    CONSTRAINT embedding_models_provider_model_key_task_type_output_dim_key UNIQUE (provider, model_key, task_type, output_dim)
);

CREATE TABLE IF NOT EXISTS ops.bot_transport_events
(
    id bigserial NOT NULL,
    bot_id uuid NOT NULL,
    event_at timestamp with time zone NOT NULL DEFAULT now(),
    event_type text COLLATE pg_catalog."default" NOT NULL,
    from_mode text COLLATE pg_catalog."default",
    to_mode text COLLATE pg_catalog."default",
    reason text COLLATE pg_catalog."default",
    details jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT bot_transport_events_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ops.errors
(
    id bigserial NOT NULL,
    tenant_id uuid,
    correlation_id uuid,
    kind text COLLATE pg_catalog."default",
    message text COLLATE pg_catalog."default",
    details jsonb,
    retryable boolean,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT errors_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ops.job_runs
(
    id bigserial NOT NULL,
    job_id bigint NOT NULL,
    started_at timestamp with time zone NOT NULL DEFAULT now(),
    finished_at timestamp with time zone,
    status ops.job_status NOT NULL,
    metrics jsonb NOT NULL DEFAULT '{}'::jsonb,
    error jsonb,
    CONSTRAINT job_runs_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ops.jobs
(
    id bigserial NOT NULL,
    tenant_id uuid NOT NULL,
    job_type ops.job_type NOT NULL,
    status ops.job_status NOT NULL DEFAULT 'queued'::ops.job_status,
    priority integer NOT NULL DEFAULT 100,
    payload jsonb NOT NULL,
    attempts integer NOT NULL DEFAULT 0,
    max_attempts integer NOT NULL DEFAULT 10,
    next_run_at timestamp with time zone DEFAULT now(),
    locked_at timestamp with time zone,
    locked_by text COLLATE pg_catalog."default",
    correlation_id uuid NOT NULL DEFAULT gen_random_uuid(),
    last_error jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT jobs_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS ops.webhook_health_snapshots
(
    id bigserial NOT NULL,
    bot_id uuid NOT NULL,
    snap_at timestamp with time zone NOT NULL DEFAULT now(),
    url text COLLATE pg_catalog."default",
    has_custom_certificate boolean,
    pending_update_count integer,
    ip_address text COLLATE pg_catalog."default",
    last_error_date timestamp with time zone,
    last_error_message text COLLATE pg_catalog."default",
    last_synchronization_error_date timestamp with time zone,
    max_connections integer,
    allowed_updates jsonb,
    last_webhook_seen_at timestamp with time zone,
    last_update_id bigint,
    "raw" jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT webhook_health_snapshots_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS "raw".telegram_update_keys
(
    tenant_id uuid NOT NULL,
    bot_id uuid NOT NULL,
    update_id bigint NOT NULL,
    first_received_at timestamp with time zone NOT NULL DEFAULT now(),
    first_request_id uuid NOT NULL DEFAULT gen_random_uuid(),
    CONSTRAINT telegram_update_keys_pkey PRIMARY KEY (bot_id, update_id)
);

CREATE TABLE IF NOT EXISTS "raw".telegram_updates
(
    tenant_id uuid NOT NULL,
    bot_id uuid NOT NULL,
    update_id bigint NOT NULL,
    update_type text COLLATE pg_catalog."default" NOT NULL,
    received_at timestamp with time zone NOT NULL DEFAULT now(),
    request_id uuid NOT NULL DEFAULT gen_random_uuid(),
    remote_ip inet,
    headers jsonb NOT NULL DEFAULT '{}'::jsonb,
    body jsonb NOT NULL,
    body_sha256 bytea NOT NULL,
    CONSTRAINT telegram_updates_pkey PRIMARY KEY (bot_id, update_id, received_at)
);

CREATE TABLE IF NOT EXISTS tg.chat_member_events
(
    id bigserial NOT NULL,
    tenant_id uuid NOT NULL,
    chat_id bigint NOT NULL,
    tg_user_id bigint NOT NULL,
    actor_user_id bigint,
    event_at timestamp with time zone NOT NULL DEFAULT now(),
    old_status text COLLATE pg_catalog."default",
    new_status text COLLATE pg_catalog."default",
    payload jsonb NOT NULL,
    CONSTRAINT chat_member_events_pkey PRIMARY KEY (id),
    CONSTRAINT chat_member_events_tenant_id_chat_id_tg_user_id_event_at_key UNIQUE (tenant_id, chat_id, tg_user_id, event_at)
);

CREATE TABLE IF NOT EXISTS tg.chat_memberships_current
(
    tenant_id uuid NOT NULL,
    chat_id bigint NOT NULL,
    tg_user_id bigint NOT NULL,
    status text COLLATE pg_catalog."default" NOT NULL,
    role_payload jsonb NOT NULL DEFAULT '{}'::jsonb,
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT chat_memberships_current_pkey PRIMARY KEY (tenant_id, chat_id, tg_user_id)
);

CREATE TABLE IF NOT EXISTS tg.chats
(
    chat_id bigint NOT NULL,
    chat_type core.chat_type NOT NULL,
    title text COLLATE pg_catalog."default",
    username citext COLLATE pg_catalog."default",
    is_forum boolean,
    parent_chat_id bigint,
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    payload jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT chats_pkey PRIMARY KEY (chat_id)
);

CREATE TABLE IF NOT EXISTS tg.file_instances
(
    file_id text COLLATE pg_catalog."default" NOT NULL,
    file_unique_id text COLLATE pg_catalog."default" NOT NULL,
    tg_file_path text COLLATE pg_catalog."default",
    last_seen_at timestamp with time zone NOT NULL DEFAULT now(),
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT file_instances_pkey PRIMARY KEY (file_id)
);

CREATE TABLE IF NOT EXISTS tg.files
(
    file_unique_id text COLLATE pg_catalog."default" NOT NULL,
    file_type text COLLATE pg_catalog."default",
    mime_type text COLLATE pg_catalog."default",
    file_name text COLLATE pg_catalog."default",
    file_size bigint,
    sha256 bytea,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    meta jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT files_pkey PRIMARY KEY (file_unique_id)
);

CREATE TABLE IF NOT EXISTS tg.message_attachments
(
    id bigserial NOT NULL,
    message_version_id bigint NOT NULL,
    attach_type text COLLATE pg_catalog."default" NOT NULL,
    file_id text COLLATE pg_catalog."default",
    file_unique_id text COLLATE pg_catalog."default",
    mime_type text COLLATE pg_catalog."default",
    file_name text COLLATE pg_catalog."default",
    file_size bigint,
    width integer,
    height integer,
    duration_sec integer,
    payload jsonb NOT NULL DEFAULT '{}'::jsonb,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT message_attachments_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS tg.message_versions
(
    id bigserial NOT NULL,
    message_fk bigint NOT NULL,
    version_no integer NOT NULL,
    sent_at timestamp with time zone NOT NULL,
    edited_at timestamp with time zone,
    from_user_id bigint,
    via_bot_user_id bigint,
    text text COLLATE pg_catalog."default",
    caption text COLLATE pg_catalog."default",
    entities jsonb,
    caption_entities jsonb,
    reply_to_message_id integer,
    forward_from_user_id bigint,
    forward_from_chat_id bigint,
    forward_date timestamp with time zone,
    has_media boolean NOT NULL DEFAULT false,
    has_links boolean NOT NULL DEFAULT false,
    normalized_text text COLLATE pg_catalog."default",
    content_sha256 bytea NOT NULL,
    payload jsonb NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    CONSTRAINT message_versions_pkey PRIMARY KEY (id),
    CONSTRAINT message_versions_message_fk_version_no_key UNIQUE (message_fk, version_no)
);

CREATE TABLE IF NOT EXISTS tg.messages
(
    id bigserial NOT NULL,
    tenant_id uuid NOT NULL,
    chat_id bigint NOT NULL,
    message_id integer NOT NULL,
    message_thread_id integer,
    is_topic_message boolean,
    visibility core.visibility_scope NOT NULL DEFAULT 'group'::core.visibility_scope,
    dm_owner_user_id bigint,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    current_version_id bigint,
    CONSTRAINT messages_pkey PRIMARY KEY (id),
    CONSTRAINT uq_tg_messages_identity UNIQUE (tenant_id, chat_id, message_id)
);

CREATE TABLE IF NOT EXISTS tg.users
(
    tg_user_id bigint NOT NULL,
    is_bot boolean NOT NULL DEFAULT false,
    first_name text COLLATE pg_catalog."default",
    last_name text COLLATE pg_catalog."default",
    username citext COLLATE pg_catalog."default",
    language_code text COLLATE pg_catalog."default",
    is_premium boolean,
    added_to_attach_menu boolean,
    updated_at timestamp with time zone NOT NULL DEFAULT now(),
    payload jsonb NOT NULL DEFAULT '{}'::jsonb,
    CONSTRAINT users_pkey PRIMARY KEY (tg_user_id)
);

ALTER TABLE IF EXISTS audit.qa_citations
    ADD CONSTRAINT qa_citations_chunk_id_fkey FOREIGN KEY (chunk_id)
    REFERENCES kg.chunks (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE RESTRICT;


ALTER TABLE IF EXISTS audit.qa_citations
    ADD CONSTRAINT qa_citations_turn_id_fkey FOREIGN KEY (turn_id)
    REFERENCES audit.qa_turns (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS audit.qa_sessions
    ADD CONSTRAINT qa_sessions_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS audit.qa_turns
    ADD CONSTRAINT qa_turns_question_msg_version_id_fkey FOREIGN KEY (question_msg_version_id)
    REFERENCES tg.message_versions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS audit.qa_turns
    ADD CONSTRAINT qa_turns_session_id_fkey FOREIGN KEY (session_id)
    REFERENCES audit.qa_sessions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS content.documents
    ADD CONSTRAINT documents_file_unique_id_fkey FOREIGN KEY (file_unique_id)
    REFERENCES tg.files (file_unique_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS content.documents
    ADD CONSTRAINT documents_message_version_id_fkey FOREIGN KEY (message_version_id)
    REFERENCES tg.message_versions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS content.documents
    ADD CONSTRAINT documents_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS content.documents
    ADD CONSTRAINT documents_url_id_fkey FOREIGN KEY (url_id)
    REFERENCES content.urls (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS content.url_fetches
    ADD CONSTRAINT url_fetches_url_id_fkey FOREIGN KEY (url_id)
    REFERENCES content.urls (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS core.bot_transport_config
    ADD CONSTRAINT bot_transport_config_bot_id_fkey FOREIGN KEY (bot_id)
    REFERENCES core.bots (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS bot_transport_config_pkey
    ON core.bot_transport_config(bot_id);


ALTER TABLE IF EXISTS core.bot_transport_state
    ADD CONSTRAINT bot_transport_state_bot_id_fkey FOREIGN KEY (bot_id)
    REFERENCES core.bots (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS bot_transport_state_pkey
    ON core.bot_transport_state(bot_id);


ALTER TABLE IF EXISTS core.bots
    ADD CONSTRAINT bots_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS core.chat_policies
    ADD CONSTRAINT chat_policies_tenant_id_chat_id_fkey FOREIGN KEY (tenant_id, chat_id)
    REFERENCES core.tenant_chats (tenant_id, chat_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS chat_policies_pkey
    ON core.chat_policies(tenant_id, chat_id);


ALTER TABLE IF EXISTS core.tenant_chats
    ADD CONSTRAINT tenant_chats_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS core.tenant_users
    ADD CONSTRAINT tenant_users_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS kg.chunk_embeddings_1536
    ADD CONSTRAINT chunk_embeddings_1536_chunk_id_fkey FOREIGN KEY (chunk_id)
    REFERENCES kg.chunks (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS kg.chunk_embeddings_1536
    ADD CONSTRAINT chunk_embeddings_1536_model_id_fkey FOREIGN KEY (model_id)
    REFERENCES kg.embedding_models (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE RESTRICT;


ALTER TABLE IF EXISTS kg.chunks
    ADD CONSTRAINT chunks_document_id_fkey FOREIGN KEY (document_id)
    REFERENCES content.documents (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS ops.bot_transport_events
    ADD CONSTRAINT bot_transport_events_bot_id_fkey FOREIGN KEY (bot_id)
    REFERENCES core.bots (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS ops.errors
    ADD CONSTRAINT errors_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE SET NULL;


ALTER TABLE IF EXISTS ops.job_runs
    ADD CONSTRAINT job_runs_job_id_fkey FOREIGN KEY (job_id)
    REFERENCES ops.jobs (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS ops.jobs
    ADD CONSTRAINT jobs_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS ops.webhook_health_snapshots
    ADD CONSTRAINT webhook_health_snapshots_bot_id_fkey FOREIGN KEY (bot_id)
    REFERENCES core.bots (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS "raw".telegram_update_keys
    ADD CONSTRAINT telegram_update_keys_bot_id_fkey FOREIGN KEY (bot_id)
    REFERENCES core.bots (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS "raw".telegram_update_keys
    ADD CONSTRAINT telegram_update_keys_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS "raw".telegram_updates
    ADD CONSTRAINT telegram_updates_bot_id_fkey FOREIGN KEY (bot_id)
    REFERENCES core.bots (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS "raw".telegram_updates
    ADD CONSTRAINT telegram_updates_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS tg.chat_member_events
    ADD CONSTRAINT chat_member_events_chat_id_fkey FOREIGN KEY (chat_id)
    REFERENCES tg.chats (chat_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS tg.chat_member_events
    ADD CONSTRAINT chat_member_events_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS tg.chat_member_events
    ADD CONSTRAINT chat_member_events_tg_user_id_fkey FOREIGN KEY (tg_user_id)
    REFERENCES tg.users (tg_user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS tg.chat_memberships_current
    ADD CONSTRAINT chat_memberships_current_chat_id_fkey FOREIGN KEY (chat_id)
    REFERENCES tg.chats (chat_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS tg.chat_memberships_current
    ADD CONSTRAINT chat_memberships_current_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS tg.chat_memberships_current
    ADD CONSTRAINT chat_memberships_current_tg_user_id_fkey FOREIGN KEY (tg_user_id)
    REFERENCES tg.users (tg_user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS tg.file_instances
    ADD CONSTRAINT file_instances_file_unique_id_fkey FOREIGN KEY (file_unique_id)
    REFERENCES tg.files (file_unique_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS ix_file_instances_unique_id
    ON tg.file_instances(file_unique_id);


ALTER TABLE IF EXISTS tg.message_attachments
    ADD CONSTRAINT message_attachments_message_version_id_fkey FOREIGN KEY (message_version_id)
    REFERENCES tg.message_versions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS ix_attach_version
    ON tg.message_attachments(message_version_id);


ALTER TABLE IF EXISTS tg.message_versions
    ADD CONSTRAINT message_versions_message_fk_fkey FOREIGN KEY (message_fk)
    REFERENCES tg.messages (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS tg.messages
    ADD CONSTRAINT fk_messages_current_version FOREIGN KEY (current_version_id)
    REFERENCES tg.message_versions (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    DEFERRABLE INITIALLY DEFERRED;


ALTER TABLE IF EXISTS tg.messages
    ADD CONSTRAINT messages_chat_id_fkey FOREIGN KEY (chat_id)
    REFERENCES tg.chats (chat_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS tg.messages
    ADD CONSTRAINT messages_tenant_id_fkey FOREIGN KEY (tenant_id)
    REFERENCES core.tenants (id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;

END;